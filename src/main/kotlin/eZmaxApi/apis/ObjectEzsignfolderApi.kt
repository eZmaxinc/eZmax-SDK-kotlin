/**
 * eZmax API Definition (Full)
 *
 * This API expose all the functionnalities for the eZmax and eZsign applications.
 *
 * The version of the OpenAPI document: 1.1.9
 * Contact: support-api@ezmax.ca
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package eZmaxApi.apis

import java.io.IOException
import okhttp3.OkHttpClient

import eZmaxApi.models.CommonMinusResponseMinusError
import eZmaxApi.models.EzsignfolderMinusArchiveMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusBatchDownloadMinusV1MinusRequest
import eZmaxApi.models.EzsignfolderMinusCreateObjectMinusV1MinusRequest
import eZmaxApi.models.EzsignfolderMinusCreateObjectMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusCreateObjectMinusV2MinusRequest
import eZmaxApi.models.EzsignfolderMinusCreateObjectMinusV2MinusResponse
import eZmaxApi.models.EzsignfolderMinusDeleteObjectMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest
import eZmaxApi.models.EzsignfolderMinusDisposeEzsignfoldersMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusDisposeMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusEditObjectMinusV1MinusRequest
import eZmaxApi.models.EzsignfolderMinusEditObjectMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusGetActionableElementsMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusGetEzsigndocumentsMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusGetEzsignfoldersignerassociationsMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusGetFormsDataMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusGetListMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusGetObjectMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest
import eZmaxApi.models.EzsignfolderMinusImportEzsigntemplatepackageMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusReorderMinusV1MinusRequest
import eZmaxApi.models.EzsignfolderMinusReorderMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusSendMinusV1MinusRequest
import eZmaxApi.models.EzsignfolderMinusSendMinusV1MinusResponse
import eZmaxApi.models.EzsignfolderMinusUnsendMinusV1MinusResponse
import eZmaxApi.models.HeaderMinusAcceptMinusLanguage

import com.squareup.moshi.Json

import eZmaxApi.infrastructure.ApiClient
import eZmaxApi.infrastructure.ApiResponse
import eZmaxApi.infrastructure.ClientException
import eZmaxApi.infrastructure.ClientError
import eZmaxApi.infrastructure.ServerException
import eZmaxApi.infrastructure.ServerError
import eZmaxApi.infrastructure.MultiValueMap
import eZmaxApi.infrastructure.PartConfig
import eZmaxApi.infrastructure.RequestConfig
import eZmaxApi.infrastructure.RequestMethod
import eZmaxApi.infrastructure.ResponseType
import eZmaxApi.infrastructure.Success
import eZmaxApi.infrastructure.toMultiValue

class ObjectEzsignfolderApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://prod.api.appcluster01.ca-central-1.ezmax.com/rest")
        }
    }

    /**
     * Archive the Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param body 
     * @return EzsignfolderMinusArchiveMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderArchiveV1(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : EzsignfolderMinusArchiveMinusV1MinusResponse {
        val localVarResponse = ezsignfolderArchiveV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusArchiveMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Archive the Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param body 
     * @return ApiResponse<EzsignfolderMinusArchiveMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderArchiveV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : ApiResponse<EzsignfolderMinusArchiveMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderArchiveV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, body = body)

        return request<kotlin.Any, EzsignfolderMinusArchiveMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderArchiveV1
     *
     * @param pkiEzsignfolderID 
     * @param body 
     * @return RequestConfig
     */
    fun ezsignfolderArchiveV1RequestConfig(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/archive".replace("{"+"pkiEzsignfolderID"+"}", "$pkiEzsignfolderID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Download multiples files from an Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusBatchDownloadMinusV1MinusRequest 
     * @return java.io.File
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderBatchDownloadV1(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusBatchDownloadMinusV1MinusRequest: EzsignfolderMinusBatchDownloadMinusV1MinusRequest) : java.io.File {
        val localVarResponse = ezsignfolderBatchDownloadV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderMinusBatchDownloadMinusV1MinusRequest = ezsignfolderMinusBatchDownloadMinusV1MinusRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as java.io.File
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Download multiples files from an Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusBatchDownloadMinusV1MinusRequest 
     * @return ApiResponse<java.io.File?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderBatchDownloadV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusBatchDownloadMinusV1MinusRequest: EzsignfolderMinusBatchDownloadMinusV1MinusRequest) : ApiResponse<java.io.File?> {
        val localVariableConfig = ezsignfolderBatchDownloadV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderMinusBatchDownloadMinusV1MinusRequest = ezsignfolderMinusBatchDownloadMinusV1MinusRequest)

        return request<EzsignfolderMinusBatchDownloadMinusV1MinusRequest, java.io.File>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderBatchDownloadV1
     *
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusBatchDownloadMinusV1MinusRequest 
     * @return RequestConfig
     */
    fun ezsignfolderBatchDownloadV1RequestConfig(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusBatchDownloadMinusV1MinusRequest: EzsignfolderMinusBatchDownloadMinusV1MinusRequest) : RequestConfig<EzsignfolderMinusBatchDownloadMinusV1MinusRequest> {
        val localVariableBody = ezsignfolderMinusBatchDownloadMinusV1MinusRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/batchDownload".replace("{"+"pkiEzsignfolderID"+"}", "$pkiEzsignfolderID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create a new Ezsignfolder
     * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
     * @param ezsignfolderMinusCreateObjectMinusV1MinusRequest 
     * @return EzsignfolderMinusCreateObjectMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun ezsignfolderCreateObjectV1(ezsignfolderMinusCreateObjectMinusV1MinusRequest: kotlin.collections.List<EzsignfolderMinusCreateObjectMinusV1MinusRequest>) : EzsignfolderMinusCreateObjectMinusV1MinusResponse {
        @Suppress("DEPRECATION")
        val localVarResponse = ezsignfolderCreateObjectV1WithHttpInfo(ezsignfolderMinusCreateObjectMinusV1MinusRequest = ezsignfolderMinusCreateObjectMinusV1MinusRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusCreateObjectMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a new Ezsignfolder
     * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
     * @param ezsignfolderMinusCreateObjectMinusV1MinusRequest 
     * @return ApiResponse<EzsignfolderMinusCreateObjectMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun ezsignfolderCreateObjectV1WithHttpInfo(ezsignfolderMinusCreateObjectMinusV1MinusRequest: kotlin.collections.List<EzsignfolderMinusCreateObjectMinusV1MinusRequest>) : ApiResponse<EzsignfolderMinusCreateObjectMinusV1MinusResponse?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = ezsignfolderCreateObjectV1RequestConfig(ezsignfolderMinusCreateObjectMinusV1MinusRequest = ezsignfolderMinusCreateObjectMinusV1MinusRequest)

        return request<kotlin.collections.List<EzsignfolderMinusCreateObjectMinusV1MinusRequest>, EzsignfolderMinusCreateObjectMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderCreateObjectV1
     *
     * @param ezsignfolderMinusCreateObjectMinusV1MinusRequest 
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun ezsignfolderCreateObjectV1RequestConfig(ezsignfolderMinusCreateObjectMinusV1MinusRequest: kotlin.collections.List<EzsignfolderMinusCreateObjectMinusV1MinusRequest>) : RequestConfig<kotlin.collections.List<EzsignfolderMinusCreateObjectMinusV1MinusRequest>> {
        val localVariableBody = ezsignfolderMinusCreateObjectMinusV1MinusRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create a new Ezsignfolder
     * The endpoint allows to create one or many elements at once.
     * @param ezsignfolderMinusCreateObjectMinusV2MinusRequest 
     * @return EzsignfolderMinusCreateObjectMinusV2MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderCreateObjectV2(ezsignfolderMinusCreateObjectMinusV2MinusRequest: EzsignfolderMinusCreateObjectMinusV2MinusRequest) : EzsignfolderMinusCreateObjectMinusV2MinusResponse {
        val localVarResponse = ezsignfolderCreateObjectV2WithHttpInfo(ezsignfolderMinusCreateObjectMinusV2MinusRequest = ezsignfolderMinusCreateObjectMinusV2MinusRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusCreateObjectMinusV2MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a new Ezsignfolder
     * The endpoint allows to create one or many elements at once.
     * @param ezsignfolderMinusCreateObjectMinusV2MinusRequest 
     * @return ApiResponse<EzsignfolderMinusCreateObjectMinusV2MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderCreateObjectV2WithHttpInfo(ezsignfolderMinusCreateObjectMinusV2MinusRequest: EzsignfolderMinusCreateObjectMinusV2MinusRequest) : ApiResponse<EzsignfolderMinusCreateObjectMinusV2MinusResponse?> {
        val localVariableConfig = ezsignfolderCreateObjectV2RequestConfig(ezsignfolderMinusCreateObjectMinusV2MinusRequest = ezsignfolderMinusCreateObjectMinusV2MinusRequest)

        return request<EzsignfolderMinusCreateObjectMinusV2MinusRequest, EzsignfolderMinusCreateObjectMinusV2MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderCreateObjectV2
     *
     * @param ezsignfolderMinusCreateObjectMinusV2MinusRequest 
     * @return RequestConfig
     */
    fun ezsignfolderCreateObjectV2RequestConfig(ezsignfolderMinusCreateObjectMinusV2MinusRequest: EzsignfolderMinusCreateObjectMinusV2MinusRequest) : RequestConfig<EzsignfolderMinusCreateObjectMinusV2MinusRequest> {
        val localVariableBody = ezsignfolderMinusCreateObjectMinusV2MinusRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/2/object/ezsignfolder",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete an existing Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderMinusDeleteObjectMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderDeleteObjectV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderMinusDeleteObjectMinusV1MinusResponse {
        val localVarResponse = ezsignfolderDeleteObjectV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusDeleteObjectMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete an existing Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderMinusDeleteObjectMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderDeleteObjectV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderMinusDeleteObjectMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderDeleteObjectV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderMinusDeleteObjectMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderDeleteObjectV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderDeleteObjectV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}".replace("{"+"pkiEzsignfolderID"+"}", "$pkiEzsignfolderID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Dispose Ezsignfolders
     * 
     * @param ezsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest 
     * @return EzsignfolderMinusDisposeEzsignfoldersMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderDisposeEzsignfoldersV1(ezsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest: EzsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest) : EzsignfolderMinusDisposeEzsignfoldersMinusV1MinusResponse {
        val localVarResponse = ezsignfolderDisposeEzsignfoldersV1WithHttpInfo(ezsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest = ezsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusDisposeEzsignfoldersMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Dispose Ezsignfolders
     * 
     * @param ezsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest 
     * @return ApiResponse<EzsignfolderMinusDisposeEzsignfoldersMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderDisposeEzsignfoldersV1WithHttpInfo(ezsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest: EzsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest) : ApiResponse<EzsignfolderMinusDisposeEzsignfoldersMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderDisposeEzsignfoldersV1RequestConfig(ezsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest = ezsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest)

        return request<EzsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest, EzsignfolderMinusDisposeEzsignfoldersMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderDisposeEzsignfoldersV1
     *
     * @param ezsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest 
     * @return RequestConfig
     */
    fun ezsignfolderDisposeEzsignfoldersV1RequestConfig(ezsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest: EzsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest) : RequestConfig<EzsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest> {
        val localVariableBody = ezsignfolderMinusDisposeEzsignfoldersMinusV1MinusRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/disposeEzsignfolders",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Dispose the Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param body 
     * @return EzsignfolderMinusDisposeMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderDisposeV1(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : EzsignfolderMinusDisposeMinusV1MinusResponse {
        val localVarResponse = ezsignfolderDisposeV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusDisposeMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Dispose the Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param body 
     * @return ApiResponse<EzsignfolderMinusDisposeMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderDisposeV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : ApiResponse<EzsignfolderMinusDisposeMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderDisposeV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, body = body)

        return request<kotlin.Any, EzsignfolderMinusDisposeMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderDisposeV1
     *
     * @param pkiEzsignfolderID 
     * @param body 
     * @return RequestConfig
     */
    fun ezsignfolderDisposeV1RequestConfig(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/dispose".replace("{"+"pkiEzsignfolderID"+"}", "$pkiEzsignfolderID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Edit an existing Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusEditObjectMinusV1MinusRequest 
     * @return EzsignfolderMinusEditObjectMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderEditObjectV1(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusEditObjectMinusV1MinusRequest: EzsignfolderMinusEditObjectMinusV1MinusRequest) : EzsignfolderMinusEditObjectMinusV1MinusResponse {
        val localVarResponse = ezsignfolderEditObjectV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderMinusEditObjectMinusV1MinusRequest = ezsignfolderMinusEditObjectMinusV1MinusRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusEditObjectMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Edit an existing Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusEditObjectMinusV1MinusRequest 
     * @return ApiResponse<EzsignfolderMinusEditObjectMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderEditObjectV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusEditObjectMinusV1MinusRequest: EzsignfolderMinusEditObjectMinusV1MinusRequest) : ApiResponse<EzsignfolderMinusEditObjectMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderEditObjectV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderMinusEditObjectMinusV1MinusRequest = ezsignfolderMinusEditObjectMinusV1MinusRequest)

        return request<EzsignfolderMinusEditObjectMinusV1MinusRequest, EzsignfolderMinusEditObjectMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderEditObjectV1
     *
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusEditObjectMinusV1MinusRequest 
     * @return RequestConfig
     */
    fun ezsignfolderEditObjectV1RequestConfig(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusEditObjectMinusV1MinusRequest: EzsignfolderMinusEditObjectMinusV1MinusRequest) : RequestConfig<EzsignfolderMinusEditObjectMinusV1MinusRequest> {
        val localVariableBody = ezsignfolderMinusEditObjectMinusV1MinusRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}".replace("{"+"pkiEzsignfolderID"+"}", "$pkiEzsignfolderID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Retrieve actionable elements for the Ezsignfolder
     * Return the Ezsignsignatures that can be signed and Ezsignformfieldgroups that can be filled by the current user at the current step in the process
     * @param pkiEzsignfolderID 
     * @return EzsignfolderMinusGetActionableElementsMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetActionableElementsV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderMinusGetActionableElementsMinusV1MinusResponse {
        val localVarResponse = ezsignfolderGetActionableElementsV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusGetActionableElementsMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve actionable elements for the Ezsignfolder
     * Return the Ezsignsignatures that can be signed and Ezsignformfieldgroups that can be filled by the current user at the current step in the process
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderMinusGetActionableElementsMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetActionableElementsV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderMinusGetActionableElementsMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderGetActionableElementsV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderMinusGetActionableElementsMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetActionableElementsV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetActionableElementsV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getActionableElements".replace("{"+"pkiEzsignfolderID"+"}", "$pkiEzsignfolderID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsignfolder&#39;s Ezsigndocuments
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderMinusGetEzsigndocumentsMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetEzsigndocumentsV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderMinusGetEzsigndocumentsMinusV1MinusResponse {
        val localVarResponse = ezsignfolderGetEzsigndocumentsV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusGetEzsigndocumentsMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsignfolder&#39;s Ezsigndocuments
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderMinusGetEzsigndocumentsMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetEzsigndocumentsV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderMinusGetEzsigndocumentsMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderGetEzsigndocumentsV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderMinusGetEzsigndocumentsMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetEzsigndocumentsV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetEzsigndocumentsV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getEzsigndocuments".replace("{"+"pkiEzsignfolderID"+"}", "$pkiEzsignfolderID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsignfolder&#39;s Ezsignfoldersignerassociations
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderMinusGetEzsignfoldersignerassociationsMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetEzsignfoldersignerassociationsV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderMinusGetEzsignfoldersignerassociationsMinusV1MinusResponse {
        val localVarResponse = ezsignfolderGetEzsignfoldersignerassociationsV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusGetEzsignfoldersignerassociationsMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsignfolder&#39;s Ezsignfoldersignerassociations
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderMinusGetEzsignfoldersignerassociationsMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetEzsignfoldersignerassociationsV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderMinusGetEzsignfoldersignerassociationsMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderGetEzsignfoldersignerassociationsV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderMinusGetEzsignfoldersignerassociationsMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetEzsignfoldersignerassociationsV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetEzsignfoldersignerassociationsV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getEzsignfoldersignerassociations".replace("{"+"pkiEzsignfolderID"+"}", "$pkiEzsignfolderID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsignfolder&#39;s forms data
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderMinusGetFormsDataMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetFormsDataV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderMinusGetFormsDataMinusV1MinusResponse {
        val localVarResponse = ezsignfolderGetFormsDataV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusGetFormsDataMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsignfolder&#39;s forms data
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderMinusGetFormsDataMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetFormsDataV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderMinusGetFormsDataMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderGetFormsDataV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderMinusGetFormsDataMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetFormsDataV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetFormsDataV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getFormsData".replace("{"+"pkiEzsignfolderID"+"}", "$pkiEzsignfolderID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter eOrderBy
     */
     enum class EOrderBy_ezsignfolderGetListV1(val value: kotlin.String) {
         @Json(name = "pkiEzsignfolderID_ASC") pkiEzsignfolderID_ASC("pkiEzsignfolderID_ASC"),
         @Json(name = "pkiEzsignfolderID_DESC") pkiEzsignfolderID_DESC("pkiEzsignfolderID_DESC"),
         @Json(name = "sEzsignfolderDescription_ASC") sEzsignfolderDescription_ASC("sEzsignfolderDescription_ASC"),
         @Json(name = "sEzsignfolderDescription_DESC") sEzsignfolderDescription_DESC("sEzsignfolderDescription_DESC"),
         @Json(name = "dtCreatedDate_ASC") dtCreatedDate_ASC("dtCreatedDate_ASC"),
         @Json(name = "dtCreatedDate_DESC") dtCreatedDate_DESC("dtCreatedDate_DESC"),
         @Json(name = "fkiEzsignfoldertypeID_ASC") fkiEzsignfoldertypeID_ASC("fkiEzsignfoldertypeID_ASC"),
         @Json(name = "fkiEzsignfoldertypeID_DESC") fkiEzsignfoldertypeID_DESC("fkiEzsignfoldertypeID_DESC"),
         @Json(name = "sEzsignfoldertypeNameX_ASC") sEzsignfoldertypeNameX_ASC("sEzsignfoldertypeNameX_ASC"),
         @Json(name = "sEzsignfoldertypeNameX_DESC") sEzsignfoldertypeNameX_DESC("sEzsignfoldertypeNameX_DESC"),
         @Json(name = "eEzsignfolderStep_ASC") eEzsignfolderStep_ASC("eEzsignfolderStep_ASC"),
         @Json(name = "eEzsignfolderStep_DESC") eEzsignfolderStep_DESC("eEzsignfolderStep_DESC"),
         @Json(name = "dtEzsignfolderSentdate_ASC") dtEzsignfolderSentdate_ASC("dtEzsignfolderSentdate_ASC"),
         @Json(name = "dtEzsignfolderSentdate_DESC") dtEzsignfolderSentdate_DESC("dtEzsignfolderSentdate_DESC"),
         @Json(name = "dtDueDate_ASC") dtDueDate_ASC("dtDueDate_ASC"),
         @Json(name = "dtDueDate_DESC") dtDueDate_DESC("dtDueDate_DESC"),
         @Json(name = "iTotalDocument_ASC") iTotalDocument_ASC("iTotalDocument_ASC"),
         @Json(name = "iTotalDocument_DESC") iTotalDocument_DESC("iTotalDocument_DESC"),
         @Json(name = "iTotalDocumentEdm_ASC") iTotalDocumentEdm_ASC("iTotalDocumentEdm_ASC"),
         @Json(name = "iTotalDocumentEdm_DESC") iTotalDocumentEdm_DESC("iTotalDocumentEdm_DESC"),
         @Json(name = "iTotalSignature_ASC") iTotalSignature_ASC("iTotalSignature_ASC"),
         @Json(name = "iTotalSignature_DESC") iTotalSignature_DESC("iTotalSignature_DESC"),
         @Json(name = "iTotalSignatureSigned_ASC") iTotalSignatureSigned_ASC("iTotalSignatureSigned_ASC"),
         @Json(name = "iTotalSignatureSigned_DESC") iTotalSignatureSigned_DESC("iTotalSignatureSigned_DESC")
     }

    /**
     * Retrieve Ezsignfolder list
     * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eEzsignfolderStep | Unsent&lt;br&gt;Sent&lt;br&gt;PartiallySigned&lt;br&gt;Expired&lt;br&gt;Completed&lt;br&gt;Archived&lt;br&gt;Disposed| | eEzsignfoldertypePrivacylevel | User&lt;br&gt;Usergroup |
     * @param eOrderBy Specify how you want the results to be sorted (optional)
     * @param iRowMax  (optional)
     * @param iRowOffset  (optional)
     * @param acceptLanguage  (optional)
     * @param sFilter  (optional)
     * @return EzsignfolderMinusGetListMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetListV1(eOrderBy: EOrderBy_ezsignfolderGetListV1? = null, iRowMax: kotlin.Int? = null, iRowOffset: kotlin.Int? = null, acceptLanguage: HeaderMinusAcceptMinusLanguage? = null, sFilter: kotlin.String? = null) : EzsignfolderMinusGetListMinusV1MinusResponse {
        val localVarResponse = ezsignfolderGetListV1WithHttpInfo(eOrderBy = eOrderBy, iRowMax = iRowMax, iRowOffset = iRowOffset, acceptLanguage = acceptLanguage, sFilter = sFilter)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusGetListMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve Ezsignfolder list
     * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eEzsignfolderStep | Unsent&lt;br&gt;Sent&lt;br&gt;PartiallySigned&lt;br&gt;Expired&lt;br&gt;Completed&lt;br&gt;Archived&lt;br&gt;Disposed| | eEzsignfoldertypePrivacylevel | User&lt;br&gt;Usergroup |
     * @param eOrderBy Specify how you want the results to be sorted (optional)
     * @param iRowMax  (optional)
     * @param iRowOffset  (optional)
     * @param acceptLanguage  (optional)
     * @param sFilter  (optional)
     * @return ApiResponse<EzsignfolderMinusGetListMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetListV1WithHttpInfo(eOrderBy: EOrderBy_ezsignfolderGetListV1?, iRowMax: kotlin.Int?, iRowOffset: kotlin.Int?, acceptLanguage: HeaderMinusAcceptMinusLanguage?, sFilter: kotlin.String?) : ApiResponse<EzsignfolderMinusGetListMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderGetListV1RequestConfig(eOrderBy = eOrderBy, iRowMax = iRowMax, iRowOffset = iRowOffset, acceptLanguage = acceptLanguage, sFilter = sFilter)

        return request<Unit, EzsignfolderMinusGetListMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetListV1
     *
     * @param eOrderBy Specify how you want the results to be sorted (optional)
     * @param iRowMax  (optional)
     * @param iRowOffset  (optional)
     * @param acceptLanguage  (optional)
     * @param sFilter  (optional)
     * @return RequestConfig
     */
    fun ezsignfolderGetListV1RequestConfig(eOrderBy: EOrderBy_ezsignfolderGetListV1?, iRowMax: kotlin.Int?, iRowOffset: kotlin.Int?, acceptLanguage: HeaderMinusAcceptMinusLanguage?, sFilter: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (eOrderBy != null) {
                    put("eOrderBy", listOf(eOrderBy.toString()))
                }
                if (iRowMax != null) {
                    put("iRowMax", listOf(iRowMax.toString()))
                }
                if (iRowOffset != null) {
                    put("iRowOffset", listOf(iRowOffset.toString()))
                }
                if (sFilter != null) {
                    put("sFilter", listOf(sFilter.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/getList",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderMinusGetObjectMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetObjectV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderMinusGetObjectMinusV1MinusResponse {
        val localVarResponse = ezsignfolderGetObjectV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusGetObjectMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderMinusGetObjectMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetObjectV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderMinusGetObjectMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderGetObjectV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderMinusGetObjectMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetObjectV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetObjectV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}".replace("{"+"pkiEzsignfolderID"+"}", "$pkiEzsignfolderID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Import an Ezsigntemplatepackage in the Ezsignfolder.
     * This endpoint imports all of the Ezsigntemplates from the Ezsigntemplatepackage into the Ezsignfolder as Ezsigndocuments.  This allows to automatically apply all the Ezsigntemplateformfieldgroups and Ezsigntemplatesignatures on the newly created Ezsigndocuments in a single step.
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest 
     * @return EzsignfolderMinusImportEzsigntemplatepackageMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderImportEzsigntemplatepackageV1(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest: EzsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest) : EzsignfolderMinusImportEzsigntemplatepackageMinusV1MinusResponse {
        val localVarResponse = ezsignfolderImportEzsigntemplatepackageV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest = ezsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusImportEzsigntemplatepackageMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Import an Ezsigntemplatepackage in the Ezsignfolder.
     * This endpoint imports all of the Ezsigntemplates from the Ezsigntemplatepackage into the Ezsignfolder as Ezsigndocuments.  This allows to automatically apply all the Ezsigntemplateformfieldgroups and Ezsigntemplatesignatures on the newly created Ezsigndocuments in a single step.
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest 
     * @return ApiResponse<EzsignfolderMinusImportEzsigntemplatepackageMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderImportEzsigntemplatepackageV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest: EzsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest) : ApiResponse<EzsignfolderMinusImportEzsigntemplatepackageMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderImportEzsigntemplatepackageV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest = ezsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest)

        return request<EzsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest, EzsignfolderMinusImportEzsigntemplatepackageMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderImportEzsigntemplatepackageV1
     *
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest 
     * @return RequestConfig
     */
    fun ezsignfolderImportEzsigntemplatepackageV1RequestConfig(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest: EzsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest) : RequestConfig<EzsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest> {
        val localVariableBody = ezsignfolderMinusImportEzsigntemplatepackageMinusV1MinusRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/importEzsigntemplatepackage".replace("{"+"pkiEzsignfolderID"+"}", "$pkiEzsignfolderID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Reorder Ezsigndocuments in the Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusReorderMinusV1MinusRequest 
     * @return EzsignfolderMinusReorderMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderReorderV1(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusReorderMinusV1MinusRequest: EzsignfolderMinusReorderMinusV1MinusRequest) : EzsignfolderMinusReorderMinusV1MinusResponse {
        val localVarResponse = ezsignfolderReorderV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderMinusReorderMinusV1MinusRequest = ezsignfolderMinusReorderMinusV1MinusRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusReorderMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Reorder Ezsigndocuments in the Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusReorderMinusV1MinusRequest 
     * @return ApiResponse<EzsignfolderMinusReorderMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderReorderV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusReorderMinusV1MinusRequest: EzsignfolderMinusReorderMinusV1MinusRequest) : ApiResponse<EzsignfolderMinusReorderMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderReorderV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderMinusReorderMinusV1MinusRequest = ezsignfolderMinusReorderMinusV1MinusRequest)

        return request<EzsignfolderMinusReorderMinusV1MinusRequest, EzsignfolderMinusReorderMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderReorderV1
     *
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusReorderMinusV1MinusRequest 
     * @return RequestConfig
     */
    fun ezsignfolderReorderV1RequestConfig(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusReorderMinusV1MinusRequest: EzsignfolderMinusReorderMinusV1MinusRequest) : RequestConfig<EzsignfolderMinusReorderMinusV1MinusRequest> {
        val localVariableBody = ezsignfolderMinusReorderMinusV1MinusRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/reorder".replace("{"+"pkiEzsignfolderID"+"}", "$pkiEzsignfolderID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Send the Ezsignfolder to the signatories for signature
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusSendMinusV1MinusRequest 
     * @return EzsignfolderMinusSendMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderSendV1(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusSendMinusV1MinusRequest: EzsignfolderMinusSendMinusV1MinusRequest) : EzsignfolderMinusSendMinusV1MinusResponse {
        val localVarResponse = ezsignfolderSendV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderMinusSendMinusV1MinusRequest = ezsignfolderMinusSendMinusV1MinusRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusSendMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Send the Ezsignfolder to the signatories for signature
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusSendMinusV1MinusRequest 
     * @return ApiResponse<EzsignfolderMinusSendMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderSendV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusSendMinusV1MinusRequest: EzsignfolderMinusSendMinusV1MinusRequest) : ApiResponse<EzsignfolderMinusSendMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderSendV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderMinusSendMinusV1MinusRequest = ezsignfolderMinusSendMinusV1MinusRequest)

        return request<EzsignfolderMinusSendMinusV1MinusRequest, EzsignfolderMinusSendMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderSendV1
     *
     * @param pkiEzsignfolderID 
     * @param ezsignfolderMinusSendMinusV1MinusRequest 
     * @return RequestConfig
     */
    fun ezsignfolderSendV1RequestConfig(pkiEzsignfolderID: kotlin.Int, ezsignfolderMinusSendMinusV1MinusRequest: EzsignfolderMinusSendMinusV1MinusRequest) : RequestConfig<EzsignfolderMinusSendMinusV1MinusRequest> {
        val localVariableBody = ezsignfolderMinusSendMinusV1MinusRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/send".replace("{"+"pkiEzsignfolderID"+"}", "$pkiEzsignfolderID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Unsend the Ezsignfolder
     * Once an Ezsignfolder has been sent to signatories, it cannot be modified.  Using this endpoint, you can unsend the Ezsignfolder and make it modifiable again.  Signatories will receive an email informing them the signature process was aborted and they might receive a new invitation to sign.   Warning: Any signature previously made by signatories on \&quot;Non-completed\&quot; Ezsigndocuments will be lost.
     * @param pkiEzsignfolderID 
     * @param body 
     * @return EzsignfolderMinusUnsendMinusV1MinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderUnsendV1(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : EzsignfolderMinusUnsendMinusV1MinusResponse {
        val localVarResponse = ezsignfolderUnsendV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderMinusUnsendMinusV1MinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Unsend the Ezsignfolder
     * Once an Ezsignfolder has been sent to signatories, it cannot be modified.  Using this endpoint, you can unsend the Ezsignfolder and make it modifiable again.  Signatories will receive an email informing them the signature process was aborted and they might receive a new invitation to sign.   Warning: Any signature previously made by signatories on \&quot;Non-completed\&quot; Ezsigndocuments will be lost.
     * @param pkiEzsignfolderID 
     * @param body 
     * @return ApiResponse<EzsignfolderMinusUnsendMinusV1MinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderUnsendV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : ApiResponse<EzsignfolderMinusUnsendMinusV1MinusResponse?> {
        val localVariableConfig = ezsignfolderUnsendV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, body = body)

        return request<kotlin.Any, EzsignfolderMinusUnsendMinusV1MinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderUnsendV1
     *
     * @param pkiEzsignfolderID 
     * @param body 
     * @return RequestConfig
     */
    fun ezsignfolderUnsendV1RequestConfig(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/unsend".replace("{"+"pkiEzsignfolderID"+"}", "$pkiEzsignfolderID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
