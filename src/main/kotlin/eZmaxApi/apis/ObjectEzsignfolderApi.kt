/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package eZmaxApi.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import eZmaxApi.models.CommonResponseError
import eZmaxApi.models.EzsignfolderArchiveV1Response
import eZmaxApi.models.EzsignfolderBatchDownloadV1Request
import eZmaxApi.models.EzsignfolderCreateObjectV1Request
import eZmaxApi.models.EzsignfolderCreateObjectV1Response
import eZmaxApi.models.EzsignfolderCreateObjectV2Request
import eZmaxApi.models.EzsignfolderCreateObjectV2Response
import eZmaxApi.models.EzsignfolderDeleteObjectV1Response
import eZmaxApi.models.EzsignfolderDisposeEzsignfoldersV1Request
import eZmaxApi.models.EzsignfolderDisposeEzsignfoldersV1Response
import eZmaxApi.models.EzsignfolderDisposeV1Response
import eZmaxApi.models.EzsignfolderEditObjectV1Request
import eZmaxApi.models.EzsignfolderEditObjectV1Response
import eZmaxApi.models.EzsignfolderEndPrematurelyV1Response
import eZmaxApi.models.EzsignfolderGetActionableElementsV1Response
import eZmaxApi.models.EzsignfolderGetAttachmentCountV1Response
import eZmaxApi.models.EzsignfolderGetAttachmentsV1Response
import eZmaxApi.models.EzsignfolderGetCommunicationCountV1Response
import eZmaxApi.models.EzsignfolderGetCommunicationListV1Response
import eZmaxApi.models.EzsignfolderGetCommunicationrecipientsV1Response
import eZmaxApi.models.EzsignfolderGetCommunicationsendersV1Response
import eZmaxApi.models.EzsignfolderGetEzsigndocumentsV1Response
import eZmaxApi.models.EzsignfolderGetEzsignfoldersignerassociationsV1Response
import eZmaxApi.models.EzsignfolderGetEzsignsignaturesAutomaticV1Response
import eZmaxApi.models.EzsignfolderGetFormsDataV1Response
import eZmaxApi.models.EzsignfolderGetListV1Response
import eZmaxApi.models.EzsignfolderGetObjectV1Response
import eZmaxApi.models.EzsignfolderGetObjectV2Response
import eZmaxApi.models.EzsignfolderImportEzsignfoldersignerassociationsV1Request
import eZmaxApi.models.EzsignfolderImportEzsignfoldersignerassociationsV1Response
import eZmaxApi.models.EzsignfolderImportEzsigntemplatepackageV1Request
import eZmaxApi.models.EzsignfolderImportEzsigntemplatepackageV1Response
import eZmaxApi.models.EzsignfolderReorderV1Request
import eZmaxApi.models.EzsignfolderReorderV1Response
import eZmaxApi.models.EzsignfolderSendV1Request
import eZmaxApi.models.EzsignfolderSendV1Response
import eZmaxApi.models.EzsignfolderSendV3Request
import eZmaxApi.models.EzsignfolderSendV3Response
import eZmaxApi.models.EzsignfolderUnsendV1Response
import eZmaxApi.models.HeaderAcceptLanguage

import com.squareup.moshi.Json

import eZmaxApi.infrastructure.ApiClient
import eZmaxApi.infrastructure.ApiResponse
import eZmaxApi.infrastructure.ClientException
import eZmaxApi.infrastructure.ClientError
import eZmaxApi.infrastructure.ServerException
import eZmaxApi.infrastructure.ServerError
import eZmaxApi.infrastructure.MultiValueMap
import eZmaxApi.infrastructure.PartConfig
import eZmaxApi.infrastructure.RequestConfig
import eZmaxApi.infrastructure.RequestMethod
import eZmaxApi.infrastructure.ResponseType
import eZmaxApi.infrastructure.Success
import eZmaxApi.infrastructure.toMultiValue

class ObjectEzsignfolderApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://prod.api.appcluster01.ca-central-1.ezmax.com/rest")
        }
    }

    /**
     * Archive the Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param body 
     * @return EzsignfolderArchiveV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderArchiveV1(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : EzsignfolderArchiveV1Response {
        val localVarResponse = ezsignfolderArchiveV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderArchiveV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Archive the Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param body 
     * @return ApiResponse<EzsignfolderArchiveV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderArchiveV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : ApiResponse<EzsignfolderArchiveV1Response?> {
        val localVariableConfig = ezsignfolderArchiveV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, body = body)

        return request<kotlin.Any, EzsignfolderArchiveV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderArchiveV1
     *
     * @param pkiEzsignfolderID 
     * @param body 
     * @return RequestConfig
     */
    fun ezsignfolderArchiveV1RequestConfig(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/archive".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Download multiples files from an Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderBatchDownloadV1Request 
     * @return java.io.File
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderBatchDownloadV1(pkiEzsignfolderID: kotlin.Int, ezsignfolderBatchDownloadV1Request: EzsignfolderBatchDownloadV1Request) : java.io.File {
        val localVarResponse = ezsignfolderBatchDownloadV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderBatchDownloadV1Request = ezsignfolderBatchDownloadV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as java.io.File
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Download multiples files from an Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderBatchDownloadV1Request 
     * @return ApiResponse<java.io.File?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderBatchDownloadV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, ezsignfolderBatchDownloadV1Request: EzsignfolderBatchDownloadV1Request) : ApiResponse<java.io.File?> {
        val localVariableConfig = ezsignfolderBatchDownloadV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderBatchDownloadV1Request = ezsignfolderBatchDownloadV1Request)

        return request<EzsignfolderBatchDownloadV1Request, java.io.File>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderBatchDownloadV1
     *
     * @param pkiEzsignfolderID 
     * @param ezsignfolderBatchDownloadV1Request 
     * @return RequestConfig
     */
    fun ezsignfolderBatchDownloadV1RequestConfig(pkiEzsignfolderID: kotlin.Int, ezsignfolderBatchDownloadV1Request: EzsignfolderBatchDownloadV1Request) : RequestConfig<EzsignfolderBatchDownloadV1Request> {
        val localVariableBody = ezsignfolderBatchDownloadV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/batchDownload".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create a new Ezsignfolder
     * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
     * @param ezsignfolderCreateObjectV1Request 
     * @return EzsignfolderCreateObjectV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request: kotlin.collections.List<EzsignfolderCreateObjectV1Request>) : EzsignfolderCreateObjectV1Response {
        @Suppress("DEPRECATION")
        val localVarResponse = ezsignfolderCreateObjectV1WithHttpInfo(ezsignfolderCreateObjectV1Request = ezsignfolderCreateObjectV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderCreateObjectV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a new Ezsignfolder
     * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
     * @param ezsignfolderCreateObjectV1Request 
     * @return ApiResponse<EzsignfolderCreateObjectV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun ezsignfolderCreateObjectV1WithHttpInfo(ezsignfolderCreateObjectV1Request: kotlin.collections.List<EzsignfolderCreateObjectV1Request>) : ApiResponse<EzsignfolderCreateObjectV1Response?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = ezsignfolderCreateObjectV1RequestConfig(ezsignfolderCreateObjectV1Request = ezsignfolderCreateObjectV1Request)

        return request<kotlin.collections.List<EzsignfolderCreateObjectV1Request>, EzsignfolderCreateObjectV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderCreateObjectV1
     *
     * @param ezsignfolderCreateObjectV1Request 
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun ezsignfolderCreateObjectV1RequestConfig(ezsignfolderCreateObjectV1Request: kotlin.collections.List<EzsignfolderCreateObjectV1Request>) : RequestConfig<kotlin.collections.List<EzsignfolderCreateObjectV1Request>> {
        val localVariableBody = ezsignfolderCreateObjectV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create a new Ezsignfolder
     * The endpoint allows to create one or many elements at once.
     * @param ezsignfolderCreateObjectV2Request 
     * @return EzsignfolderCreateObjectV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderCreateObjectV2(ezsignfolderCreateObjectV2Request: EzsignfolderCreateObjectV2Request) : EzsignfolderCreateObjectV2Response {
        val localVarResponse = ezsignfolderCreateObjectV2WithHttpInfo(ezsignfolderCreateObjectV2Request = ezsignfolderCreateObjectV2Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderCreateObjectV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a new Ezsignfolder
     * The endpoint allows to create one or many elements at once.
     * @param ezsignfolderCreateObjectV2Request 
     * @return ApiResponse<EzsignfolderCreateObjectV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderCreateObjectV2WithHttpInfo(ezsignfolderCreateObjectV2Request: EzsignfolderCreateObjectV2Request) : ApiResponse<EzsignfolderCreateObjectV2Response?> {
        val localVariableConfig = ezsignfolderCreateObjectV2RequestConfig(ezsignfolderCreateObjectV2Request = ezsignfolderCreateObjectV2Request)

        return request<EzsignfolderCreateObjectV2Request, EzsignfolderCreateObjectV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderCreateObjectV2
     *
     * @param ezsignfolderCreateObjectV2Request 
     * @return RequestConfig
     */
    fun ezsignfolderCreateObjectV2RequestConfig(ezsignfolderCreateObjectV2Request: EzsignfolderCreateObjectV2Request) : RequestConfig<EzsignfolderCreateObjectV2Request> {
        val localVariableBody = ezsignfolderCreateObjectV2Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/2/object/ezsignfolder",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete an existing Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderDeleteObjectV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderDeleteObjectV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderDeleteObjectV1Response {
        val localVarResponse = ezsignfolderDeleteObjectV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderDeleteObjectV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete an existing Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderDeleteObjectV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderDeleteObjectV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderDeleteObjectV1Response?> {
        val localVariableConfig = ezsignfolderDeleteObjectV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderDeleteObjectV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderDeleteObjectV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderDeleteObjectV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Dispose Ezsignfolders
     * 
     * @param ezsignfolderDisposeEzsignfoldersV1Request 
     * @return EzsignfolderDisposeEzsignfoldersV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderDisposeEzsignfoldersV1(ezsignfolderDisposeEzsignfoldersV1Request: EzsignfolderDisposeEzsignfoldersV1Request) : EzsignfolderDisposeEzsignfoldersV1Response {
        val localVarResponse = ezsignfolderDisposeEzsignfoldersV1WithHttpInfo(ezsignfolderDisposeEzsignfoldersV1Request = ezsignfolderDisposeEzsignfoldersV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderDisposeEzsignfoldersV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Dispose Ezsignfolders
     * 
     * @param ezsignfolderDisposeEzsignfoldersV1Request 
     * @return ApiResponse<EzsignfolderDisposeEzsignfoldersV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderDisposeEzsignfoldersV1WithHttpInfo(ezsignfolderDisposeEzsignfoldersV1Request: EzsignfolderDisposeEzsignfoldersV1Request) : ApiResponse<EzsignfolderDisposeEzsignfoldersV1Response?> {
        val localVariableConfig = ezsignfolderDisposeEzsignfoldersV1RequestConfig(ezsignfolderDisposeEzsignfoldersV1Request = ezsignfolderDisposeEzsignfoldersV1Request)

        return request<EzsignfolderDisposeEzsignfoldersV1Request, EzsignfolderDisposeEzsignfoldersV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderDisposeEzsignfoldersV1
     *
     * @param ezsignfolderDisposeEzsignfoldersV1Request 
     * @return RequestConfig
     */
    fun ezsignfolderDisposeEzsignfoldersV1RequestConfig(ezsignfolderDisposeEzsignfoldersV1Request: EzsignfolderDisposeEzsignfoldersV1Request) : RequestConfig<EzsignfolderDisposeEzsignfoldersV1Request> {
        val localVariableBody = ezsignfolderDisposeEzsignfoldersV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/disposeEzsignfolders",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Dispose the Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param body 
     * @return EzsignfolderDisposeV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderDisposeV1(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : EzsignfolderDisposeV1Response {
        val localVarResponse = ezsignfolderDisposeV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderDisposeV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Dispose the Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param body 
     * @return ApiResponse<EzsignfolderDisposeV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderDisposeV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : ApiResponse<EzsignfolderDisposeV1Response?> {
        val localVariableConfig = ezsignfolderDisposeV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, body = body)

        return request<kotlin.Any, EzsignfolderDisposeV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderDisposeV1
     *
     * @param pkiEzsignfolderID 
     * @param body 
     * @return RequestConfig
     */
    fun ezsignfolderDisposeV1RequestConfig(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/dispose".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Edit an existing Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderEditObjectV1Request 
     * @return EzsignfolderEditObjectV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderEditObjectV1(pkiEzsignfolderID: kotlin.Int, ezsignfolderEditObjectV1Request: EzsignfolderEditObjectV1Request) : EzsignfolderEditObjectV1Response {
        val localVarResponse = ezsignfolderEditObjectV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderEditObjectV1Request = ezsignfolderEditObjectV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderEditObjectV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Edit an existing Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderEditObjectV1Request 
     * @return ApiResponse<EzsignfolderEditObjectV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderEditObjectV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, ezsignfolderEditObjectV1Request: EzsignfolderEditObjectV1Request) : ApiResponse<EzsignfolderEditObjectV1Response?> {
        val localVariableConfig = ezsignfolderEditObjectV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderEditObjectV1Request = ezsignfolderEditObjectV1Request)

        return request<EzsignfolderEditObjectV1Request, EzsignfolderEditObjectV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderEditObjectV1
     *
     * @param pkiEzsignfolderID 
     * @param ezsignfolderEditObjectV1Request 
     * @return RequestConfig
     */
    fun ezsignfolderEditObjectV1RequestConfig(pkiEzsignfolderID: kotlin.Int, ezsignfolderEditObjectV1Request: EzsignfolderEditObjectV1Request) : RequestConfig<EzsignfolderEditObjectV1Request> {
        val localVariableBody = ezsignfolderEditObjectV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * End prematurely
     * End prematurely all Ezsigndocument of Ezsignfolder when some signatures are still required
     * @param pkiEzsignfolderID 
     * @param body 
     * @return EzsignfolderEndPrematurelyV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderEndPrematurelyV1(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : EzsignfolderEndPrematurelyV1Response {
        val localVarResponse = ezsignfolderEndPrematurelyV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderEndPrematurelyV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * End prematurely
     * End prematurely all Ezsigndocument of Ezsignfolder when some signatures are still required
     * @param pkiEzsignfolderID 
     * @param body 
     * @return ApiResponse<EzsignfolderEndPrematurelyV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderEndPrematurelyV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : ApiResponse<EzsignfolderEndPrematurelyV1Response?> {
        val localVariableConfig = ezsignfolderEndPrematurelyV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, body = body)

        return request<kotlin.Any, EzsignfolderEndPrematurelyV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderEndPrematurelyV1
     *
     * @param pkiEzsignfolderID 
     * @param body 
     * @return RequestConfig
     */
    fun ezsignfolderEndPrematurelyV1RequestConfig(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/endPrematurely".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve actionable elements for the Ezsignfolder
     * Return the Ezsignsignatures that can be signed and Ezsignformfieldgroups that can be filled by the current user at the current step in the process
     * @param pkiEzsignfolderID 
     * @return EzsignfolderGetActionableElementsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetActionableElementsV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderGetActionableElementsV1Response {
        val localVarResponse = ezsignfolderGetActionableElementsV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderGetActionableElementsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve actionable elements for the Ezsignfolder
     * Return the Ezsignsignatures that can be signed and Ezsignformfieldgroups that can be filled by the current user at the current step in the process
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderGetActionableElementsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetActionableElementsV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderGetActionableElementsV1Response?> {
        val localVariableConfig = ezsignfolderGetActionableElementsV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderGetActionableElementsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetActionableElementsV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetActionableElementsV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getActionableElements".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve Attachment count
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderGetAttachmentCountV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetAttachmentCountV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderGetAttachmentCountV1Response {
        val localVarResponse = ezsignfolderGetAttachmentCountV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderGetAttachmentCountV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve Attachment count
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderGetAttachmentCountV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetAttachmentCountV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderGetAttachmentCountV1Response?> {
        val localVariableConfig = ezsignfolderGetAttachmentCountV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderGetAttachmentCountV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetAttachmentCountV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetAttachmentCountV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getAttachmentCount".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve Ezsignfolder&#39;s Attachments
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderGetAttachmentsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetAttachmentsV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderGetAttachmentsV1Response {
        val localVarResponse = ezsignfolderGetAttachmentsV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderGetAttachmentsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve Ezsignfolder&#39;s Attachments
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderGetAttachmentsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetAttachmentsV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderGetAttachmentsV1Response?> {
        val localVariableConfig = ezsignfolderGetAttachmentsV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderGetAttachmentsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetAttachmentsV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetAttachmentsV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getAttachments".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve Communication count
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderGetCommunicationCountV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetCommunicationCountV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderGetCommunicationCountV1Response {
        val localVarResponse = ezsignfolderGetCommunicationCountV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderGetCommunicationCountV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve Communication count
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderGetCommunicationCountV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetCommunicationCountV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderGetCommunicationCountV1Response?> {
        val localVariableConfig = ezsignfolderGetCommunicationCountV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderGetCommunicationCountV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetCommunicationCountV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetCommunicationCountV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getCommunicationCount".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve Communication list
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderGetCommunicationListV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetCommunicationListV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderGetCommunicationListV1Response {
        val localVarResponse = ezsignfolderGetCommunicationListV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderGetCommunicationListV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve Communication list
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderGetCommunicationListV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetCommunicationListV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderGetCommunicationListV1Response?> {
        val localVariableConfig = ezsignfolderGetCommunicationListV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderGetCommunicationListV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetCommunicationListV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetCommunicationListV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getCommunicationList".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve Ezsignfolder&#39;s Communicationrecipient
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderGetCommunicationrecipientsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetCommunicationrecipientsV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderGetCommunicationrecipientsV1Response {
        val localVarResponse = ezsignfolderGetCommunicationrecipientsV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderGetCommunicationrecipientsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve Ezsignfolder&#39;s Communicationrecipient
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderGetCommunicationrecipientsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetCommunicationrecipientsV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderGetCommunicationrecipientsV1Response?> {
        val localVariableConfig = ezsignfolderGetCommunicationrecipientsV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderGetCommunicationrecipientsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetCommunicationrecipientsV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetCommunicationrecipientsV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getCommunicationrecipients".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve Ezsignfolder&#39;s Communicationsender
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderGetCommunicationsendersV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetCommunicationsendersV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderGetCommunicationsendersV1Response {
        val localVarResponse = ezsignfolderGetCommunicationsendersV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderGetCommunicationsendersV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve Ezsignfolder&#39;s Communicationsender
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderGetCommunicationsendersV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetCommunicationsendersV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderGetCommunicationsendersV1Response?> {
        val localVariableConfig = ezsignfolderGetCommunicationsendersV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderGetCommunicationsendersV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetCommunicationsendersV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetCommunicationsendersV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getCommunicationsenders".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsignfolder&#39;s Ezsigndocuments
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderGetEzsigndocumentsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetEzsigndocumentsV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderGetEzsigndocumentsV1Response {
        val localVarResponse = ezsignfolderGetEzsigndocumentsV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderGetEzsigndocumentsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsignfolder&#39;s Ezsigndocuments
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderGetEzsigndocumentsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetEzsigndocumentsV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderGetEzsigndocumentsV1Response?> {
        val localVariableConfig = ezsignfolderGetEzsigndocumentsV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderGetEzsigndocumentsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetEzsigndocumentsV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetEzsigndocumentsV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getEzsigndocuments".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsignfolder&#39;s Ezsignfoldersignerassociations
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderGetEzsignfoldersignerassociationsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetEzsignfoldersignerassociationsV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderGetEzsignfoldersignerassociationsV1Response {
        val localVarResponse = ezsignfolderGetEzsignfoldersignerassociationsV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderGetEzsignfoldersignerassociationsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsignfolder&#39;s Ezsignfoldersignerassociations
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderGetEzsignfoldersignerassociationsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetEzsignfoldersignerassociationsV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderGetEzsignfoldersignerassociationsV1Response?> {
        val localVariableConfig = ezsignfolderGetEzsignfoldersignerassociationsV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderGetEzsignfoldersignerassociationsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetEzsignfoldersignerassociationsV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetEzsignfoldersignerassociationsV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getEzsignfoldersignerassociations".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsignfolder&#39;s automatic Ezsignsignatures
     * Return the Ezsignsignatures that can be signed by the current user at the current step in the process
     * @param pkiEzsignfolderID 
     * @return EzsignfolderGetEzsignsignaturesAutomaticV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetEzsignsignaturesAutomaticV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderGetEzsignsignaturesAutomaticV1Response {
        val localVarResponse = ezsignfolderGetEzsignsignaturesAutomaticV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderGetEzsignsignaturesAutomaticV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsignfolder&#39;s automatic Ezsignsignatures
     * Return the Ezsignsignatures that can be signed by the current user at the current step in the process
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderGetEzsignsignaturesAutomaticV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetEzsignsignaturesAutomaticV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderGetEzsignsignaturesAutomaticV1Response?> {
        val localVariableConfig = ezsignfolderGetEzsignsignaturesAutomaticV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderGetEzsignsignaturesAutomaticV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetEzsignsignaturesAutomaticV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetEzsignsignaturesAutomaticV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getEzsignsignaturesAutomatic".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsignfolder&#39;s forms data
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderGetFormsDataV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetFormsDataV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderGetFormsDataV1Response {
        val localVarResponse = ezsignfolderGetFormsDataV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderGetFormsDataV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsignfolder&#39;s forms data
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderGetFormsDataV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetFormsDataV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderGetFormsDataV1Response?> {
        val localVariableConfig = ezsignfolderGetFormsDataV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderGetFormsDataV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetFormsDataV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetFormsDataV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/getFormsData".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter eOrderBy
     */
     enum class EOrderByEzsignfolderGetListV1(val value: kotlin.String) {
         @Json(name = "pkiEzsignfolderID_ASC") pkiEzsignfolderID_ASC("pkiEzsignfolderID_ASC"),
         @Json(name = "pkiEzsignfolderID_DESC") pkiEzsignfolderID_DESC("pkiEzsignfolderID_DESC"),
         @Json(name = "sEzsignfolderDescription_ASC") sEzsignfolderDescription_ASC("sEzsignfolderDescription_ASC"),
         @Json(name = "sEzsignfolderDescription_DESC") sEzsignfolderDescription_DESC("sEzsignfolderDescription_DESC"),
         @Json(name = "dtCreatedDate_ASC") dtCreatedDate_ASC("dtCreatedDate_ASC"),
         @Json(name = "dtCreatedDate_DESC") dtCreatedDate_DESC("dtCreatedDate_DESC"),
         @Json(name = "fkiEzsignfoldertypeID_ASC") fkiEzsignfoldertypeID_ASC("fkiEzsignfoldertypeID_ASC"),
         @Json(name = "fkiEzsignfoldertypeID_DESC") fkiEzsignfoldertypeID_DESC("fkiEzsignfoldertypeID_DESC"),
         @Json(name = "sEzsignfoldertypeNameX_ASC") sEzsignfoldertypeNameX_ASC("sEzsignfoldertypeNameX_ASC"),
         @Json(name = "sEzsignfoldertypeNameX_DESC") sEzsignfoldertypeNameX_DESC("sEzsignfoldertypeNameX_DESC"),
         @Json(name = "eEzsignfolderStep_ASC") eEzsignfolderStep_ASC("eEzsignfolderStep_ASC"),
         @Json(name = "eEzsignfolderStep_DESC") eEzsignfolderStep_DESC("eEzsignfolderStep_DESC"),
         @Json(name = "dtEzsignfolderSentdate_ASC") dtEzsignfolderSentdate_ASC("dtEzsignfolderSentdate_ASC"),
         @Json(name = "dtEzsignfolderSentdate_DESC") dtEzsignfolderSentdate_DESC("dtEzsignfolderSentdate_DESC"),
         @Json(name = "dtEzsignfolderDuedate_ASC") dtEzsignfolderDuedate_ASC("dtEzsignfolderDuedate_ASC"),
         @Json(name = "dtEzsignfolderDuedate_DESC") dtEzsignfolderDuedate_DESC("dtEzsignfolderDuedate_DESC"),
         @Json(name = "iEzsigndocument_ASC") iEzsigndocument_ASC("iEzsigndocument_ASC"),
         @Json(name = "iEzsigndocument_DESC") iEzsigndocument_DESC("iEzsigndocument_DESC"),
         @Json(name = "iEzsigndocumentEdm_ASC") iEzsigndocumentEdm_ASC("iEzsigndocumentEdm_ASC"),
         @Json(name = "iEzsigndocumentEdm_DESC") iEzsigndocumentEdm_DESC("iEzsigndocumentEdm_DESC"),
         @Json(name = "iEzsignsignature_ASC") iEzsignsignature_ASC("iEzsignsignature_ASC"),
         @Json(name = "iEzsignsignature_DESC") iEzsignsignature_DESC("iEzsignsignature_DESC"),
         @Json(name = "iEzsignsignatureSigned_ASC") iEzsignsignatureSigned_ASC("iEzsignsignatureSigned_ASC"),
         @Json(name = "iEzsignsignatureSigned_DESC") iEzsignsignatureSigned_DESC("iEzsignsignatureSigned_DESC"),
         @Json(name = "iEzsignformfieldgroup_ASC") iEzsignformfieldgroup_ASC("iEzsignformfieldgroup_ASC"),
         @Json(name = "iEzsignformfieldgroup_DESC") iEzsignformfieldgroup_DESC("iEzsignformfieldgroup_DESC"),
         @Json(name = "iEzsignformfieldgroupCompleted_ASC") iEzsignformfieldgroupCompleted_ASC("iEzsignformfieldgroupCompleted_ASC"),
         @Json(name = "iEzsignformfieldgroupCompleted_DESC") iEzsignformfieldgroupCompleted_DESC("iEzsignformfieldgroupCompleted_DESC"),
         @Json(name = "dEzsignfolderCompletedpercentage_ASC") dEzsignfolderCompletedpercentage_ASC("dEzsignfolderCompletedpercentage_ASC"),
         @Json(name = "dEzsignfolderCompletedpercentage_DESC") dEzsignfolderCompletedpercentage_DESC("dEzsignfolderCompletedpercentage_DESC")
     }

    /**
     * Retrieve Ezsignfolder list
     * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eEzsignfolderStep | Unsent&lt;br&gt;Sent&lt;br&gt;PartiallySigned&lt;br&gt;Expired&lt;br&gt;Completed&lt;br&gt;Archived&lt;br&gt;Disposed| | eEzsignfoldertypePrivacylevel | User&lt;br&gt;Usergroup |  Advanced filters that can be used in query parameter *sFilter*:  | Variable | |---| | fkiUserID | | sContactFirstname | | sContactLastname | | sEzsigndocumentName |
     * @param eOrderBy Specify how you want the results to be sorted (optional)
     * @param iRowMax  (optional)
     * @param iRowOffset  (optional, default to 0)
     * @param acceptLanguage  (optional)
     * @param sFilter  (optional)
     * @return EzsignfolderGetListV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetListV1(eOrderBy: EOrderByEzsignfolderGetListV1? = null, iRowMax: kotlin.Int? = null, iRowOffset: kotlin.Int? = 0, acceptLanguage: HeaderAcceptLanguage? = null, sFilter: kotlin.String? = null) : EzsignfolderGetListV1Response {
        val localVarResponse = ezsignfolderGetListV1WithHttpInfo(eOrderBy = eOrderBy, iRowMax = iRowMax, iRowOffset = iRowOffset, acceptLanguage = acceptLanguage, sFilter = sFilter)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderGetListV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve Ezsignfolder list
     * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eEzsignfolderStep | Unsent&lt;br&gt;Sent&lt;br&gt;PartiallySigned&lt;br&gt;Expired&lt;br&gt;Completed&lt;br&gt;Archived&lt;br&gt;Disposed| | eEzsignfoldertypePrivacylevel | User&lt;br&gt;Usergroup |  Advanced filters that can be used in query parameter *sFilter*:  | Variable | |---| | fkiUserID | | sContactFirstname | | sContactLastname | | sEzsigndocumentName |
     * @param eOrderBy Specify how you want the results to be sorted (optional)
     * @param iRowMax  (optional)
     * @param iRowOffset  (optional, default to 0)
     * @param acceptLanguage  (optional)
     * @param sFilter  (optional)
     * @return ApiResponse<EzsignfolderGetListV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetListV1WithHttpInfo(eOrderBy: EOrderByEzsignfolderGetListV1?, iRowMax: kotlin.Int?, iRowOffset: kotlin.Int?, acceptLanguage: HeaderAcceptLanguage?, sFilter: kotlin.String?) : ApiResponse<EzsignfolderGetListV1Response?> {
        val localVariableConfig = ezsignfolderGetListV1RequestConfig(eOrderBy = eOrderBy, iRowMax = iRowMax, iRowOffset = iRowOffset, acceptLanguage = acceptLanguage, sFilter = sFilter)

        return request<Unit, EzsignfolderGetListV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetListV1
     *
     * @param eOrderBy Specify how you want the results to be sorted (optional)
     * @param iRowMax  (optional)
     * @param iRowOffset  (optional, default to 0)
     * @param acceptLanguage  (optional)
     * @param sFilter  (optional)
     * @return RequestConfig
     */
    fun ezsignfolderGetListV1RequestConfig(eOrderBy: EOrderByEzsignfolderGetListV1?, iRowMax: kotlin.Int?, iRowOffset: kotlin.Int?, acceptLanguage: HeaderAcceptLanguage?, sFilter: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (eOrderBy != null) {
                    put("eOrderBy", listOf(eOrderBy.value))
                }
                if (iRowMax != null) {
                    put("iRowMax", listOf(iRowMax.toString()))
                }
                if (iRowOffset != null) {
                    put("iRowOffset", listOf(iRowOffset.toString()))
                }
                if (sFilter != null) {
                    put("sFilter", listOf(sFilter.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/getList",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderGetObjectV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun ezsignfolderGetObjectV1(pkiEzsignfolderID: kotlin.Int) : EzsignfolderGetObjectV1Response {
        @Suppress("DEPRECATION")
        val localVarResponse = ezsignfolderGetObjectV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderGetObjectV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderGetObjectV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun ezsignfolderGetObjectV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderGetObjectV1Response?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = ezsignfolderGetObjectV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderGetObjectV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetObjectV1
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun ezsignfolderGetObjectV1RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @return EzsignfolderGetObjectV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderGetObjectV2(pkiEzsignfolderID: kotlin.Int) : EzsignfolderGetObjectV2Response {
        val localVarResponse = ezsignfolderGetObjectV2WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderGetObjectV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @return ApiResponse<EzsignfolderGetObjectV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderGetObjectV2WithHttpInfo(pkiEzsignfolderID: kotlin.Int) : ApiResponse<EzsignfolderGetObjectV2Response?> {
        val localVariableConfig = ezsignfolderGetObjectV2RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID)

        return request<Unit, EzsignfolderGetObjectV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderGetObjectV2
     *
     * @param pkiEzsignfolderID 
     * @return RequestConfig
     */
    fun ezsignfolderGetObjectV2RequestConfig(pkiEzsignfolderID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/object/ezsignfolder/{pkiEzsignfolderID}".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Import an existing Ezsignfoldersignerassociation into this Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderImportEzsignfoldersignerassociationsV1Request 
     * @return EzsignfolderImportEzsignfoldersignerassociationsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderImportEzsignfoldersignerassociationsV1(pkiEzsignfolderID: kotlin.Int, ezsignfolderImportEzsignfoldersignerassociationsV1Request: EzsignfolderImportEzsignfoldersignerassociationsV1Request) : EzsignfolderImportEzsignfoldersignerassociationsV1Response {
        val localVarResponse = ezsignfolderImportEzsignfoldersignerassociationsV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderImportEzsignfoldersignerassociationsV1Request = ezsignfolderImportEzsignfoldersignerassociationsV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderImportEzsignfoldersignerassociationsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Import an existing Ezsignfoldersignerassociation into this Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderImportEzsignfoldersignerassociationsV1Request 
     * @return ApiResponse<EzsignfolderImportEzsignfoldersignerassociationsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderImportEzsignfoldersignerassociationsV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, ezsignfolderImportEzsignfoldersignerassociationsV1Request: EzsignfolderImportEzsignfoldersignerassociationsV1Request) : ApiResponse<EzsignfolderImportEzsignfoldersignerassociationsV1Response?> {
        val localVariableConfig = ezsignfolderImportEzsignfoldersignerassociationsV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderImportEzsignfoldersignerassociationsV1Request = ezsignfolderImportEzsignfoldersignerassociationsV1Request)

        return request<EzsignfolderImportEzsignfoldersignerassociationsV1Request, EzsignfolderImportEzsignfoldersignerassociationsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderImportEzsignfoldersignerassociationsV1
     *
     * @param pkiEzsignfolderID 
     * @param ezsignfolderImportEzsignfoldersignerassociationsV1Request 
     * @return RequestConfig
     */
    fun ezsignfolderImportEzsignfoldersignerassociationsV1RequestConfig(pkiEzsignfolderID: kotlin.Int, ezsignfolderImportEzsignfoldersignerassociationsV1Request: EzsignfolderImportEzsignfoldersignerassociationsV1Request) : RequestConfig<EzsignfolderImportEzsignfoldersignerassociationsV1Request> {
        val localVariableBody = ezsignfolderImportEzsignfoldersignerassociationsV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/importEzsignfoldersignerassociations".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Import an Ezsigntemplatepackage in the Ezsignfolder.
     * This endpoint imports all of the Ezsigntemplates from the Ezsigntemplatepackage into the Ezsignfolder as Ezsigndocuments.  This allows to automatically apply all the Ezsigntemplateformfieldgroups and Ezsigntemplatesignatures on the newly created Ezsigndocuments in a single step.
     * @param pkiEzsignfolderID 
     * @param ezsignfolderImportEzsigntemplatepackageV1Request 
     * @return EzsignfolderImportEzsigntemplatepackageV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderImportEzsigntemplatepackageV1(pkiEzsignfolderID: kotlin.Int, ezsignfolderImportEzsigntemplatepackageV1Request: EzsignfolderImportEzsigntemplatepackageV1Request) : EzsignfolderImportEzsigntemplatepackageV1Response {
        val localVarResponse = ezsignfolderImportEzsigntemplatepackageV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderImportEzsigntemplatepackageV1Request = ezsignfolderImportEzsigntemplatepackageV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderImportEzsigntemplatepackageV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Import an Ezsigntemplatepackage in the Ezsignfolder.
     * This endpoint imports all of the Ezsigntemplates from the Ezsigntemplatepackage into the Ezsignfolder as Ezsigndocuments.  This allows to automatically apply all the Ezsigntemplateformfieldgroups and Ezsigntemplatesignatures on the newly created Ezsigndocuments in a single step.
     * @param pkiEzsignfolderID 
     * @param ezsignfolderImportEzsigntemplatepackageV1Request 
     * @return ApiResponse<EzsignfolderImportEzsigntemplatepackageV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderImportEzsigntemplatepackageV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, ezsignfolderImportEzsigntemplatepackageV1Request: EzsignfolderImportEzsigntemplatepackageV1Request) : ApiResponse<EzsignfolderImportEzsigntemplatepackageV1Response?> {
        val localVariableConfig = ezsignfolderImportEzsigntemplatepackageV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderImportEzsigntemplatepackageV1Request = ezsignfolderImportEzsigntemplatepackageV1Request)

        return request<EzsignfolderImportEzsigntemplatepackageV1Request, EzsignfolderImportEzsigntemplatepackageV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderImportEzsigntemplatepackageV1
     *
     * @param pkiEzsignfolderID 
     * @param ezsignfolderImportEzsigntemplatepackageV1Request 
     * @return RequestConfig
     */
    fun ezsignfolderImportEzsigntemplatepackageV1RequestConfig(pkiEzsignfolderID: kotlin.Int, ezsignfolderImportEzsigntemplatepackageV1Request: EzsignfolderImportEzsigntemplatepackageV1Request) : RequestConfig<EzsignfolderImportEzsigntemplatepackageV1Request> {
        val localVariableBody = ezsignfolderImportEzsigntemplatepackageV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/importEzsigntemplatepackage".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Reorder Ezsigndocuments in the Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderReorderV1Request 
     * @return EzsignfolderReorderV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderReorderV1(pkiEzsignfolderID: kotlin.Int, ezsignfolderReorderV1Request: EzsignfolderReorderV1Request) : EzsignfolderReorderV1Response {
        val localVarResponse = ezsignfolderReorderV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderReorderV1Request = ezsignfolderReorderV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderReorderV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Reorder Ezsigndocuments in the Ezsignfolder
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderReorderV1Request 
     * @return ApiResponse<EzsignfolderReorderV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderReorderV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, ezsignfolderReorderV1Request: EzsignfolderReorderV1Request) : ApiResponse<EzsignfolderReorderV1Response?> {
        val localVariableConfig = ezsignfolderReorderV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderReorderV1Request = ezsignfolderReorderV1Request)

        return request<EzsignfolderReorderV1Request, EzsignfolderReorderV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderReorderV1
     *
     * @param pkiEzsignfolderID 
     * @param ezsignfolderReorderV1Request 
     * @return RequestConfig
     */
    fun ezsignfolderReorderV1RequestConfig(pkiEzsignfolderID: kotlin.Int, ezsignfolderReorderV1Request: EzsignfolderReorderV1Request) : RequestConfig<EzsignfolderReorderV1Request> {
        val localVariableBody = ezsignfolderReorderV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/reorder".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Send the Ezsignfolder to the signatories for signature
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderSendV1Request 
     * @return EzsignfolderSendV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun ezsignfolderSendV1(pkiEzsignfolderID: kotlin.Int, ezsignfolderSendV1Request: EzsignfolderSendV1Request) : EzsignfolderSendV1Response {
        @Suppress("DEPRECATION")
        val localVarResponse = ezsignfolderSendV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderSendV1Request = ezsignfolderSendV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderSendV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Send the Ezsignfolder to the signatories for signature
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderSendV1Request 
     * @return ApiResponse<EzsignfolderSendV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun ezsignfolderSendV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, ezsignfolderSendV1Request: EzsignfolderSendV1Request) : ApiResponse<EzsignfolderSendV1Response?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = ezsignfolderSendV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderSendV1Request = ezsignfolderSendV1Request)

        return request<EzsignfolderSendV1Request, EzsignfolderSendV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderSendV1
     *
     * @param pkiEzsignfolderID 
     * @param ezsignfolderSendV1Request 
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun ezsignfolderSendV1RequestConfig(pkiEzsignfolderID: kotlin.Int, ezsignfolderSendV1Request: EzsignfolderSendV1Request) : RequestConfig<EzsignfolderSendV1Request> {
        val localVariableBody = ezsignfolderSendV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/send".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Send the Ezsignfolder to the signatories for signature
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderSendV3Request 
     * @return EzsignfolderSendV3Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderSendV3(pkiEzsignfolderID: kotlin.Int, ezsignfolderSendV3Request: EzsignfolderSendV3Request) : EzsignfolderSendV3Response {
        val localVarResponse = ezsignfolderSendV3WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderSendV3Request = ezsignfolderSendV3Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderSendV3Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Send the Ezsignfolder to the signatories for signature
     * 
     * @param pkiEzsignfolderID 
     * @param ezsignfolderSendV3Request 
     * @return ApiResponse<EzsignfolderSendV3Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderSendV3WithHttpInfo(pkiEzsignfolderID: kotlin.Int, ezsignfolderSendV3Request: EzsignfolderSendV3Request) : ApiResponse<EzsignfolderSendV3Response?> {
        val localVariableConfig = ezsignfolderSendV3RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, ezsignfolderSendV3Request = ezsignfolderSendV3Request)

        return request<EzsignfolderSendV3Request, EzsignfolderSendV3Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderSendV3
     *
     * @param pkiEzsignfolderID 
     * @param ezsignfolderSendV3Request 
     * @return RequestConfig
     */
    fun ezsignfolderSendV3RequestConfig(pkiEzsignfolderID: kotlin.Int, ezsignfolderSendV3Request: EzsignfolderSendV3Request) : RequestConfig<EzsignfolderSendV3Request> {
        val localVariableBody = ezsignfolderSendV3Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/3/object/ezsignfolder/{pkiEzsignfolderID}/send".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Unsend the Ezsignfolder
     * Once an Ezsignfolder has been sent to signatories, it cannot be modified.  Using this endpoint, you can unsend the Ezsignfolder and make it modifiable again.  Signatories will receive an email informing them the signature process was aborted and they might receive a new invitation to sign.   Warning: Any signature previously made by signatories on \&quot;Non-completed\&quot; Ezsigndocuments will be lost.
     * @param pkiEzsignfolderID 
     * @param body 
     * @return EzsignfolderUnsendV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsignfolderUnsendV1(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : EzsignfolderUnsendV1Response {
        val localVarResponse = ezsignfolderUnsendV1WithHttpInfo(pkiEzsignfolderID = pkiEzsignfolderID, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsignfolderUnsendV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Unsend the Ezsignfolder
     * Once an Ezsignfolder has been sent to signatories, it cannot be modified.  Using this endpoint, you can unsend the Ezsignfolder and make it modifiable again.  Signatories will receive an email informing them the signature process was aborted and they might receive a new invitation to sign.   Warning: Any signature previously made by signatories on \&quot;Non-completed\&quot; Ezsigndocuments will be lost.
     * @param pkiEzsignfolderID 
     * @param body 
     * @return ApiResponse<EzsignfolderUnsendV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsignfolderUnsendV1WithHttpInfo(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : ApiResponse<EzsignfolderUnsendV1Response?> {
        val localVariableConfig = ezsignfolderUnsendV1RequestConfig(pkiEzsignfolderID = pkiEzsignfolderID, body = body)

        return request<kotlin.Any, EzsignfolderUnsendV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsignfolderUnsendV1
     *
     * @param pkiEzsignfolderID 
     * @param body 
     * @return RequestConfig
     */
    fun ezsignfolderUnsendV1RequestConfig(pkiEzsignfolderID: kotlin.Int, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsignfolder/{pkiEzsignfolderID}/unsend".replace("{"+"pkiEzsignfolderID"+"}", encodeURIComponent(pkiEzsignfolderID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
