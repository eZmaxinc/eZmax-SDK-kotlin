/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package eZmaxApi.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import eZmaxApi.models.CommonResponseError
import eZmaxApi.models.CommonResponseErrorEzsignformValidation
import eZmaxApi.models.CommonResponseErrorSTemporaryFileUrl
import eZmaxApi.models.EzsigndocumentApplyEzsigntemplateV1Request
import eZmaxApi.models.EzsigndocumentApplyEzsigntemplateV1Response
import eZmaxApi.models.EzsigndocumentApplyEzsigntemplateV2Request
import eZmaxApi.models.EzsigndocumentApplyEzsigntemplateV2Response
import eZmaxApi.models.EzsigndocumentCreateEzsignelementsPositionedByWordV1Request
import eZmaxApi.models.EzsigndocumentCreateEzsignelementsPositionedByWordV1Response
import eZmaxApi.models.EzsigndocumentCreateObjectV1Request
import eZmaxApi.models.EzsigndocumentCreateObjectV1Response
import eZmaxApi.models.EzsigndocumentCreateObjectV2Request
import eZmaxApi.models.EzsigndocumentCreateObjectV2Response
import eZmaxApi.models.EzsigndocumentDeclineToSignV1Request
import eZmaxApi.models.EzsigndocumentDeclineToSignV1Response
import eZmaxApi.models.EzsigndocumentDeleteObjectV1Response
import eZmaxApi.models.EzsigndocumentEditEzsignformfieldgroupsV1Request
import eZmaxApi.models.EzsigndocumentEditEzsignformfieldgroupsV1Response
import eZmaxApi.models.EzsigndocumentEditEzsignsignaturesV1Request
import eZmaxApi.models.EzsigndocumentEditEzsignsignaturesV1Response
import eZmaxApi.models.EzsigndocumentEndPrematurelyV1Response
import eZmaxApi.models.EzsigndocumentFlattenV1Response
import eZmaxApi.models.EzsigndocumentGetActionableElementsV1Response
import eZmaxApi.models.EzsigndocumentGetAttachmentsV1Response
import eZmaxApi.models.EzsigndocumentGetCompletedElementsV1Response
import eZmaxApi.models.EzsigndocumentGetDownloadUrlV1Response
import eZmaxApi.models.EzsigndocumentGetEzsignannotationsV1Response
import eZmaxApi.models.EzsigndocumentGetEzsigndiscussionsV1Response
import eZmaxApi.models.EzsigndocumentGetEzsignformfieldgroupsV1Response
import eZmaxApi.models.EzsigndocumentGetEzsignpagesV1Response
import eZmaxApi.models.EzsigndocumentGetEzsignsignaturesAutomaticV1Response
import eZmaxApi.models.EzsigndocumentGetEzsignsignaturesV1Response
import eZmaxApi.models.EzsigndocumentGetFormDataV1Response
import eZmaxApi.models.EzsigndocumentGetObjectV1Response
import eZmaxApi.models.EzsigndocumentGetObjectV2Response
import eZmaxApi.models.EzsigndocumentGetTemporaryProofV1Response
import eZmaxApi.models.EzsigndocumentGetWordsPositionsV1Request
import eZmaxApi.models.EzsigndocumentGetWordsPositionsV1Response
import eZmaxApi.models.EzsigndocumentPatchObjectV1Request
import eZmaxApi.models.EzsigndocumentPatchObjectV1Response
import eZmaxApi.models.EzsigndocumentSubmitEzsignformV1Request
import eZmaxApi.models.EzsigndocumentSubmitEzsignformV1Response
import eZmaxApi.models.EzsigndocumentUnsendV1Response

import com.squareup.moshi.Json

import eZmaxApi.infrastructure.ApiClient
import eZmaxApi.infrastructure.ApiResponse
import eZmaxApi.infrastructure.ClientException
import eZmaxApi.infrastructure.ClientError
import eZmaxApi.infrastructure.ServerException
import eZmaxApi.infrastructure.ServerError
import eZmaxApi.infrastructure.MultiValueMap
import eZmaxApi.infrastructure.PartConfig
import eZmaxApi.infrastructure.RequestConfig
import eZmaxApi.infrastructure.RequestMethod
import eZmaxApi.infrastructure.ResponseType
import eZmaxApi.infrastructure.Success
import eZmaxApi.infrastructure.toMultiValue

class ObjectEzsigndocumentApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://prod.api.appcluster01.ca-central-1.ezmax.com/rest")
        }
    }

    /**
     * Apply an Ezsigntemplate to the Ezsigndocument.
     * This function is deprecated. Please use *applyEzsigntemplate* instead which is doing the same thing but with a capital \&quot;E\&quot; to normalize the nomenclature.  This endpoint applies a predefined template to the ezsign document. This allows to automatically apply all the form and signature fields on a document in a single step.  The document must not already have fields otherwise an error will be returned.
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentApplyEzsigntemplateV1Request 
     * @return EzsigndocumentApplyEzsigntemplateV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun ezsigndocumentApplyEzsigntemplateV1(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentApplyEzsigntemplateV1Request: EzsigndocumentApplyEzsigntemplateV1Request) : EzsigndocumentApplyEzsigntemplateV1Response {
        @Suppress("DEPRECATION")
        val localVarResponse = ezsigndocumentApplyEzsigntemplateV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentApplyEzsigntemplateV1Request = ezsigndocumentApplyEzsigntemplateV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentApplyEzsigntemplateV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Apply an Ezsigntemplate to the Ezsigndocument.
     * This function is deprecated. Please use *applyEzsigntemplate* instead which is doing the same thing but with a capital \&quot;E\&quot; to normalize the nomenclature.  This endpoint applies a predefined template to the ezsign document. This allows to automatically apply all the form and signature fields on a document in a single step.  The document must not already have fields otherwise an error will be returned.
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentApplyEzsigntemplateV1Request 
     * @return ApiResponse<EzsigndocumentApplyEzsigntemplateV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun ezsigndocumentApplyEzsigntemplateV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentApplyEzsigntemplateV1Request: EzsigndocumentApplyEzsigntemplateV1Request) : ApiResponse<EzsigndocumentApplyEzsigntemplateV1Response?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = ezsigndocumentApplyEzsigntemplateV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentApplyEzsigntemplateV1Request = ezsigndocumentApplyEzsigntemplateV1Request)

        return request<EzsigndocumentApplyEzsigntemplateV1Request, EzsigndocumentApplyEzsigntemplateV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentApplyEzsigntemplateV1
     *
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentApplyEzsigntemplateV1Request 
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun ezsigndocumentApplyEzsigntemplateV1RequestConfig(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentApplyEzsigntemplateV1Request: EzsigndocumentApplyEzsigntemplateV1Request) : RequestConfig<EzsigndocumentApplyEzsigntemplateV1Request> {
        val localVariableBody = ezsigndocumentApplyEzsigntemplateV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/applyezsigntemplate".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Apply an Ezsigntemplate to the Ezsigndocument.
     * This endpoint applies a predefined template to the ezsign document. This allows to automatically apply all the form and signature fields on a document in a single step.  The document must not already have fields otherwise an error will be returned.
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentApplyEzsigntemplateV2Request 
     * @return EzsigndocumentApplyEzsigntemplateV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentApplyEzsigntemplateV2(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentApplyEzsigntemplateV2Request: EzsigndocumentApplyEzsigntemplateV2Request) : EzsigndocumentApplyEzsigntemplateV2Response {
        val localVarResponse = ezsigndocumentApplyEzsigntemplateV2WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentApplyEzsigntemplateV2Request = ezsigndocumentApplyEzsigntemplateV2Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentApplyEzsigntemplateV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Apply an Ezsigntemplate to the Ezsigndocument.
     * This endpoint applies a predefined template to the ezsign document. This allows to automatically apply all the form and signature fields on a document in a single step.  The document must not already have fields otherwise an error will be returned.
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentApplyEzsigntemplateV2Request 
     * @return ApiResponse<EzsigndocumentApplyEzsigntemplateV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentApplyEzsigntemplateV2WithHttpInfo(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentApplyEzsigntemplateV2Request: EzsigndocumentApplyEzsigntemplateV2Request) : ApiResponse<EzsigndocumentApplyEzsigntemplateV2Response?> {
        val localVariableConfig = ezsigndocumentApplyEzsigntemplateV2RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentApplyEzsigntemplateV2Request = ezsigndocumentApplyEzsigntemplateV2Request)

        return request<EzsigndocumentApplyEzsigntemplateV2Request, EzsigndocumentApplyEzsigntemplateV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentApplyEzsigntemplateV2
     *
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentApplyEzsigntemplateV2Request 
     * @return RequestConfig
     */
    fun ezsigndocumentApplyEzsigntemplateV2RequestConfig(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentApplyEzsigntemplateV2Request: EzsigndocumentApplyEzsigntemplateV2Request) : RequestConfig<EzsigndocumentApplyEzsigntemplateV2Request> {
        val localVariableBody = ezsigndocumentApplyEzsigntemplateV2Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/2/object/ezsigndocument/{pkiEzsigndocumentID}/applyEzsigntemplate".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create multiple Ezsignsignatures/Ezsignformfieldgroups
     * Using this endpoint, you can create multiple Ezsignsignatures/Ezsignformfieldgroups positioned by word at the same time.
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentCreateEzsignelementsPositionedByWordV1Request 
     * @return EzsigndocumentCreateEzsignelementsPositionedByWordV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentCreateEzsignelementsPositionedByWordV1(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentCreateEzsignelementsPositionedByWordV1Request: EzsigndocumentCreateEzsignelementsPositionedByWordV1Request) : EzsigndocumentCreateEzsignelementsPositionedByWordV1Response {
        val localVarResponse = ezsigndocumentCreateEzsignelementsPositionedByWordV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentCreateEzsignelementsPositionedByWordV1Request = ezsigndocumentCreateEzsignelementsPositionedByWordV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentCreateEzsignelementsPositionedByWordV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create multiple Ezsignsignatures/Ezsignformfieldgroups
     * Using this endpoint, you can create multiple Ezsignsignatures/Ezsignformfieldgroups positioned by word at the same time.
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentCreateEzsignelementsPositionedByWordV1Request 
     * @return ApiResponse<EzsigndocumentCreateEzsignelementsPositionedByWordV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentCreateEzsignelementsPositionedByWordV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentCreateEzsignelementsPositionedByWordV1Request: EzsigndocumentCreateEzsignelementsPositionedByWordV1Request) : ApiResponse<EzsigndocumentCreateEzsignelementsPositionedByWordV1Response?> {
        val localVariableConfig = ezsigndocumentCreateEzsignelementsPositionedByWordV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentCreateEzsignelementsPositionedByWordV1Request = ezsigndocumentCreateEzsignelementsPositionedByWordV1Request)

        return request<EzsigndocumentCreateEzsignelementsPositionedByWordV1Request, EzsigndocumentCreateEzsignelementsPositionedByWordV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentCreateEzsignelementsPositionedByWordV1
     *
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentCreateEzsignelementsPositionedByWordV1Request 
     * @return RequestConfig
     */
    fun ezsigndocumentCreateEzsignelementsPositionedByWordV1RequestConfig(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentCreateEzsignelementsPositionedByWordV1Request: EzsigndocumentCreateEzsignelementsPositionedByWordV1Request) : RequestConfig<EzsigndocumentCreateEzsignelementsPositionedByWordV1Request> {
        val localVariableBody = ezsigndocumentCreateEzsignelementsPositionedByWordV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/createEzsignelementsPositionedByWord".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create a new Ezsigndocument
     * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
     * @param ezsigndocumentCreateObjectV1Request 
     * @return EzsigndocumentCreateObjectV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun ezsigndocumentCreateObjectV1(ezsigndocumentCreateObjectV1Request: kotlin.collections.List<EzsigndocumentCreateObjectV1Request>) : EzsigndocumentCreateObjectV1Response {
        @Suppress("DEPRECATION")
        val localVarResponse = ezsigndocumentCreateObjectV1WithHttpInfo(ezsigndocumentCreateObjectV1Request = ezsigndocumentCreateObjectV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentCreateObjectV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a new Ezsigndocument
     * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
     * @param ezsigndocumentCreateObjectV1Request 
     * @return ApiResponse<EzsigndocumentCreateObjectV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun ezsigndocumentCreateObjectV1WithHttpInfo(ezsigndocumentCreateObjectV1Request: kotlin.collections.List<EzsigndocumentCreateObjectV1Request>) : ApiResponse<EzsigndocumentCreateObjectV1Response?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = ezsigndocumentCreateObjectV1RequestConfig(ezsigndocumentCreateObjectV1Request = ezsigndocumentCreateObjectV1Request)

        return request<kotlin.collections.List<EzsigndocumentCreateObjectV1Request>, EzsigndocumentCreateObjectV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentCreateObjectV1
     *
     * @param ezsigndocumentCreateObjectV1Request 
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun ezsigndocumentCreateObjectV1RequestConfig(ezsigndocumentCreateObjectV1Request: kotlin.collections.List<EzsigndocumentCreateObjectV1Request>) : RequestConfig<kotlin.collections.List<EzsigndocumentCreateObjectV1Request>> {
        val localVariableBody = ezsigndocumentCreateObjectV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsigndocument",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create a new Ezsigndocument
     * The endpoint allows to create one or many elements at once.
     * @param ezsigndocumentCreateObjectV2Request 
     * @return EzsigndocumentCreateObjectV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentCreateObjectV2(ezsigndocumentCreateObjectV2Request: EzsigndocumentCreateObjectV2Request) : EzsigndocumentCreateObjectV2Response {
        val localVarResponse = ezsigndocumentCreateObjectV2WithHttpInfo(ezsigndocumentCreateObjectV2Request = ezsigndocumentCreateObjectV2Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentCreateObjectV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a new Ezsigndocument
     * The endpoint allows to create one or many elements at once.
     * @param ezsigndocumentCreateObjectV2Request 
     * @return ApiResponse<EzsigndocumentCreateObjectV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentCreateObjectV2WithHttpInfo(ezsigndocumentCreateObjectV2Request: EzsigndocumentCreateObjectV2Request) : ApiResponse<EzsigndocumentCreateObjectV2Response?> {
        val localVariableConfig = ezsigndocumentCreateObjectV2RequestConfig(ezsigndocumentCreateObjectV2Request = ezsigndocumentCreateObjectV2Request)

        return request<EzsigndocumentCreateObjectV2Request, EzsigndocumentCreateObjectV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentCreateObjectV2
     *
     * @param ezsigndocumentCreateObjectV2Request 
     * @return RequestConfig
     */
    fun ezsigndocumentCreateObjectV2RequestConfig(ezsigndocumentCreateObjectV2Request: EzsigndocumentCreateObjectV2Request) : RequestConfig<EzsigndocumentCreateObjectV2Request> {
        val localVariableBody = ezsigndocumentCreateObjectV2Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/2/object/ezsigndocument",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Decline to sign
     * Decline to sign
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentDeclineToSignV1Request 
     * @return EzsigndocumentDeclineToSignV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentDeclineToSignV1(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentDeclineToSignV1Request: EzsigndocumentDeclineToSignV1Request) : EzsigndocumentDeclineToSignV1Response {
        val localVarResponse = ezsigndocumentDeclineToSignV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentDeclineToSignV1Request = ezsigndocumentDeclineToSignV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentDeclineToSignV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Decline to sign
     * Decline to sign
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentDeclineToSignV1Request 
     * @return ApiResponse<EzsigndocumentDeclineToSignV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentDeclineToSignV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentDeclineToSignV1Request: EzsigndocumentDeclineToSignV1Request) : ApiResponse<EzsigndocumentDeclineToSignV1Response?> {
        val localVariableConfig = ezsigndocumentDeclineToSignV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentDeclineToSignV1Request = ezsigndocumentDeclineToSignV1Request)

        return request<EzsigndocumentDeclineToSignV1Request, EzsigndocumentDeclineToSignV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentDeclineToSignV1
     *
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentDeclineToSignV1Request 
     * @return RequestConfig
     */
    fun ezsigndocumentDeclineToSignV1RequestConfig(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentDeclineToSignV1Request: EzsigndocumentDeclineToSignV1Request) : RequestConfig<EzsigndocumentDeclineToSignV1Request> {
        val localVariableBody = ezsigndocumentDeclineToSignV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/declineToSign".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete an existing Ezsigndocument
     * 
     * @param pkiEzsigndocumentID 
     * @return EzsigndocumentDeleteObjectV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentDeleteObjectV1(pkiEzsigndocumentID: kotlin.Int) : EzsigndocumentDeleteObjectV1Response {
        val localVarResponse = ezsigndocumentDeleteObjectV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentDeleteObjectV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete an existing Ezsigndocument
     * 
     * @param pkiEzsigndocumentID 
     * @return ApiResponse<EzsigndocumentDeleteObjectV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentDeleteObjectV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int) : ApiResponse<EzsigndocumentDeleteObjectV1Response?> {
        val localVariableConfig = ezsigndocumentDeleteObjectV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return request<Unit, EzsigndocumentDeleteObjectV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentDeleteObjectV1
     *
     * @param pkiEzsigndocumentID 
     * @return RequestConfig
     */
    fun ezsigndocumentDeleteObjectV1RequestConfig(pkiEzsigndocumentID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Edit multiple Ezsignformfieldgroups
     * Using this endpoint, you can edit multiple Ezsignformfieldgroups at the same time.
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentEditEzsignformfieldgroupsV1Request 
     * @return EzsigndocumentEditEzsignformfieldgroupsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentEditEzsignformfieldgroupsV1(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentEditEzsignformfieldgroupsV1Request: EzsigndocumentEditEzsignformfieldgroupsV1Request) : EzsigndocumentEditEzsignformfieldgroupsV1Response {
        val localVarResponse = ezsigndocumentEditEzsignformfieldgroupsV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentEditEzsignformfieldgroupsV1Request = ezsigndocumentEditEzsignformfieldgroupsV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentEditEzsignformfieldgroupsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Edit multiple Ezsignformfieldgroups
     * Using this endpoint, you can edit multiple Ezsignformfieldgroups at the same time.
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentEditEzsignformfieldgroupsV1Request 
     * @return ApiResponse<EzsigndocumentEditEzsignformfieldgroupsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentEditEzsignformfieldgroupsV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentEditEzsignformfieldgroupsV1Request: EzsigndocumentEditEzsignformfieldgroupsV1Request) : ApiResponse<EzsigndocumentEditEzsignformfieldgroupsV1Response?> {
        val localVariableConfig = ezsigndocumentEditEzsignformfieldgroupsV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentEditEzsignformfieldgroupsV1Request = ezsigndocumentEditEzsignformfieldgroupsV1Request)

        return request<EzsigndocumentEditEzsignformfieldgroupsV1Request, EzsigndocumentEditEzsignformfieldgroupsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentEditEzsignformfieldgroupsV1
     *
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentEditEzsignformfieldgroupsV1Request 
     * @return RequestConfig
     */
    fun ezsigndocumentEditEzsignformfieldgroupsV1RequestConfig(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentEditEzsignformfieldgroupsV1Request: EzsigndocumentEditEzsignformfieldgroupsV1Request) : RequestConfig<EzsigndocumentEditEzsignformfieldgroupsV1Request> {
        val localVariableBody = ezsigndocumentEditEzsignformfieldgroupsV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/editEzsignformfieldgroups".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Edit multiple Ezsignsignatures
     * Using this endpoint, you can edit multiple Ezsignsignatures at the same time.
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentEditEzsignsignaturesV1Request 
     * @return EzsigndocumentEditEzsignsignaturesV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentEditEzsignsignaturesV1(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentEditEzsignsignaturesV1Request: EzsigndocumentEditEzsignsignaturesV1Request) : EzsigndocumentEditEzsignsignaturesV1Response {
        val localVarResponse = ezsigndocumentEditEzsignsignaturesV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentEditEzsignsignaturesV1Request = ezsigndocumentEditEzsignsignaturesV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentEditEzsignsignaturesV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Edit multiple Ezsignsignatures
     * Using this endpoint, you can edit multiple Ezsignsignatures at the same time.
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentEditEzsignsignaturesV1Request 
     * @return ApiResponse<EzsigndocumentEditEzsignsignaturesV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentEditEzsignsignaturesV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentEditEzsignsignaturesV1Request: EzsigndocumentEditEzsignsignaturesV1Request) : ApiResponse<EzsigndocumentEditEzsignsignaturesV1Response?> {
        val localVariableConfig = ezsigndocumentEditEzsignsignaturesV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentEditEzsignsignaturesV1Request = ezsigndocumentEditEzsignsignaturesV1Request)

        return request<EzsigndocumentEditEzsignsignaturesV1Request, EzsigndocumentEditEzsignsignaturesV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentEditEzsignsignaturesV1
     *
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentEditEzsignsignaturesV1Request 
     * @return RequestConfig
     */
    fun ezsigndocumentEditEzsignsignaturesV1RequestConfig(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentEditEzsignsignaturesV1Request: EzsigndocumentEditEzsignsignaturesV1Request) : RequestConfig<EzsigndocumentEditEzsignsignaturesV1Request> {
        val localVariableBody = ezsigndocumentEditEzsignsignaturesV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/editEzsignsignatures".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * End prematurely
     * End prematurely an Ezsigndocument when some signatures are still required
     * @param pkiEzsigndocumentID 
     * @param body 
     * @return EzsigndocumentEndPrematurelyV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentEndPrematurelyV1(pkiEzsigndocumentID: kotlin.Int, body: kotlin.Any) : EzsigndocumentEndPrematurelyV1Response {
        val localVarResponse = ezsigndocumentEndPrematurelyV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentEndPrematurelyV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * End prematurely
     * End prematurely an Ezsigndocument when some signatures are still required
     * @param pkiEzsigndocumentID 
     * @param body 
     * @return ApiResponse<EzsigndocumentEndPrematurelyV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentEndPrematurelyV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int, body: kotlin.Any) : ApiResponse<EzsigndocumentEndPrematurelyV1Response?> {
        val localVariableConfig = ezsigndocumentEndPrematurelyV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID, body = body)

        return request<kotlin.Any, EzsigndocumentEndPrematurelyV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentEndPrematurelyV1
     *
     * @param pkiEzsigndocumentID 
     * @param body 
     * @return RequestConfig
     */
    fun ezsigndocumentEndPrematurelyV1RequestConfig(pkiEzsigndocumentID: kotlin.Int, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/endPrematurely".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Flatten
     * Flatten an Ezsigndocument signatures, forms and annotations. This process finalizes the PDF so that the forms and annotations become part of the document content and cannot be edited.
     * @param pkiEzsigndocumentID 
     * @param body 
     * @return EzsigndocumentFlattenV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentFlattenV1(pkiEzsigndocumentID: kotlin.Int, body: kotlin.Any) : EzsigndocumentFlattenV1Response {
        val localVarResponse = ezsigndocumentFlattenV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentFlattenV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Flatten
     * Flatten an Ezsigndocument signatures, forms and annotations. This process finalizes the PDF so that the forms and annotations become part of the document content and cannot be edited.
     * @param pkiEzsigndocumentID 
     * @param body 
     * @return ApiResponse<EzsigndocumentFlattenV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentFlattenV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int, body: kotlin.Any) : ApiResponse<EzsigndocumentFlattenV1Response?> {
        val localVariableConfig = ezsigndocumentFlattenV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID, body = body)

        return request<kotlin.Any, EzsigndocumentFlattenV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentFlattenV1
     *
     * @param pkiEzsigndocumentID 
     * @param body 
     * @return RequestConfig
     */
    fun ezsigndocumentFlattenV1RequestConfig(pkiEzsigndocumentID: kotlin.Int, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/flatten".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve actionable elements for the Ezsigndocument
     * Return the Ezsignsignatures that can be signed and Ezsignformfieldgroups that can be filled by the current user at the current step in the process
     * @param pkiEzsigndocumentID 
     * @return EzsigndocumentGetActionableElementsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentGetActionableElementsV1(pkiEzsigndocumentID: kotlin.Int) : EzsigndocumentGetActionableElementsV1Response {
        val localVarResponse = ezsigndocumentGetActionableElementsV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetActionableElementsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve actionable elements for the Ezsigndocument
     * Return the Ezsignsignatures that can be signed and Ezsignformfieldgroups that can be filled by the current user at the current step in the process
     * @param pkiEzsigndocumentID 
     * @return ApiResponse<EzsigndocumentGetActionableElementsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentGetActionableElementsV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int) : ApiResponse<EzsigndocumentGetActionableElementsV1Response?> {
        val localVariableConfig = ezsigndocumentGetActionableElementsV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return request<Unit, EzsigndocumentGetActionableElementsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetActionableElementsV1
     *
     * @param pkiEzsigndocumentID 
     * @return RequestConfig
     */
    fun ezsigndocumentGetActionableElementsV1RequestConfig(pkiEzsigndocumentID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/getActionableElements".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve Ezsigndocument&#39;s Attachments
     * 
     * @param pkiEzsigndocumentID 
     * @return EzsigndocumentGetAttachmentsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentGetAttachmentsV1(pkiEzsigndocumentID: kotlin.Int) : EzsigndocumentGetAttachmentsV1Response {
        val localVarResponse = ezsigndocumentGetAttachmentsV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetAttachmentsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve Ezsigndocument&#39;s Attachments
     * 
     * @param pkiEzsigndocumentID 
     * @return ApiResponse<EzsigndocumentGetAttachmentsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentGetAttachmentsV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int) : ApiResponse<EzsigndocumentGetAttachmentsV1Response?> {
        val localVariableConfig = ezsigndocumentGetAttachmentsV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return request<Unit, EzsigndocumentGetAttachmentsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetAttachmentsV1
     *
     * @param pkiEzsigndocumentID 
     * @return RequestConfig
     */
    fun ezsigndocumentGetAttachmentsV1RequestConfig(pkiEzsigndocumentID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/getAttachments".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve completed elements for the Ezsigndocument
     * Return the completed Ezsignsignatures, Ezsignformfieldgroups and Ezsignannotations at the current step in the process
     * @param pkiEzsigndocumentID 
     * @return EzsigndocumentGetCompletedElementsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentGetCompletedElementsV1(pkiEzsigndocumentID: kotlin.Int) : EzsigndocumentGetCompletedElementsV1Response {
        val localVarResponse = ezsigndocumentGetCompletedElementsV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetCompletedElementsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve completed elements for the Ezsigndocument
     * Return the completed Ezsignsignatures, Ezsignformfieldgroups and Ezsignannotations at the current step in the process
     * @param pkiEzsigndocumentID 
     * @return ApiResponse<EzsigndocumentGetCompletedElementsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentGetCompletedElementsV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int) : ApiResponse<EzsigndocumentGetCompletedElementsV1Response?> {
        val localVariableConfig = ezsigndocumentGetCompletedElementsV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return request<Unit, EzsigndocumentGetCompletedElementsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetCompletedElementsV1
     *
     * @param pkiEzsigndocumentID 
     * @return RequestConfig
     */
    fun ezsigndocumentGetCompletedElementsV1RequestConfig(pkiEzsigndocumentID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/getCompletedElements".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter eDocumentType
     */
     enum class EDocumentTypeEzsigndocumentGetDownloadUrlV1(val value: kotlin.String) {
         @Json(name = "Initial") Initial("Initial"),
         @Json(name = "SignatureReady") SignatureReady("SignatureReady"),
         @Json(name = "Signed") Signed("Signed"),
         @Json(name = "Proof") Proof("Proof"),
         @Json(name = "Proofdocument") Proofdocument("Proofdocument")
     }

    /**
     * Retrieve a URL to download documents.
     * This endpoint returns URLs to different files that can be downloaded during the signing process.  These links will expire after 5 minutes so the download of the file should be made soon after retrieving the link.
     * @param pkiEzsigndocumentID 
     * @param eDocumentType The type of document to retrieve.  1. **Initial** Is the initial document before any signature were applied. 2. **SignatureReady** Is the version containing the annotations/form to show the signer. 3. **Signed** Is the final document once all signatures were applied in current document if eEzsignfolderCompletion is PerEzsigndocument.&lt;br&gt;     Is the final document once all signatures were applied in all documents if eEzsignfolderCompletion is PerEzsignfolder. 4. **Proofdocument** Is the evidence report. 5. **Proof** Is the complete evidence archive including all of the above and more. 
     * @return EzsigndocumentGetDownloadUrlV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentGetDownloadUrlV1(pkiEzsigndocumentID: kotlin.Int, eDocumentType: EDocumentTypeEzsigndocumentGetDownloadUrlV1) : EzsigndocumentGetDownloadUrlV1Response {
        val localVarResponse = ezsigndocumentGetDownloadUrlV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID, eDocumentType = eDocumentType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetDownloadUrlV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve a URL to download documents.
     * This endpoint returns URLs to different files that can be downloaded during the signing process.  These links will expire after 5 minutes so the download of the file should be made soon after retrieving the link.
     * @param pkiEzsigndocumentID 
     * @param eDocumentType The type of document to retrieve.  1. **Initial** Is the initial document before any signature were applied. 2. **SignatureReady** Is the version containing the annotations/form to show the signer. 3. **Signed** Is the final document once all signatures were applied in current document if eEzsignfolderCompletion is PerEzsigndocument.&lt;br&gt;     Is the final document once all signatures were applied in all documents if eEzsignfolderCompletion is PerEzsignfolder. 4. **Proofdocument** Is the evidence report. 5. **Proof** Is the complete evidence archive including all of the above and more. 
     * @return ApiResponse<EzsigndocumentGetDownloadUrlV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentGetDownloadUrlV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int, eDocumentType: EDocumentTypeEzsigndocumentGetDownloadUrlV1) : ApiResponse<EzsigndocumentGetDownloadUrlV1Response?> {
        val localVariableConfig = ezsigndocumentGetDownloadUrlV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID, eDocumentType = eDocumentType)

        return request<Unit, EzsigndocumentGetDownloadUrlV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetDownloadUrlV1
     *
     * @param pkiEzsigndocumentID 
     * @param eDocumentType The type of document to retrieve.  1. **Initial** Is the initial document before any signature were applied. 2. **SignatureReady** Is the version containing the annotations/form to show the signer. 3. **Signed** Is the final document once all signatures were applied in current document if eEzsignfolderCompletion is PerEzsigndocument.&lt;br&gt;     Is the final document once all signatures were applied in all documents if eEzsignfolderCompletion is PerEzsignfolder. 4. **Proofdocument** Is the evidence report. 5. **Proof** Is the complete evidence archive including all of the above and more. 
     * @return RequestConfig
     */
    fun ezsigndocumentGetDownloadUrlV1RequestConfig(pkiEzsigndocumentID: kotlin.Int, eDocumentType: EDocumentTypeEzsigndocumentGetDownloadUrlV1) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/getDownloadUrl/{eDocumentType}".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())).replace("{"+"eDocumentType"+"}", encodeURIComponent(eDocumentType.value.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsigndocument&#39;s Ezsignannotations
     * 
     * @param pkiEzsigndocumentID 
     * @return EzsigndocumentGetEzsignannotationsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentGetEzsignannotationsV1(pkiEzsigndocumentID: kotlin.Int) : EzsigndocumentGetEzsignannotationsV1Response {
        val localVarResponse = ezsigndocumentGetEzsignannotationsV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetEzsignannotationsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsigndocument&#39;s Ezsignannotations
     * 
     * @param pkiEzsigndocumentID 
     * @return ApiResponse<EzsigndocumentGetEzsignannotationsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentGetEzsignannotationsV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int) : ApiResponse<EzsigndocumentGetEzsignannotationsV1Response?> {
        val localVariableConfig = ezsigndocumentGetEzsignannotationsV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return request<Unit, EzsigndocumentGetEzsignannotationsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetEzsignannotationsV1
     *
     * @param pkiEzsigndocumentID 
     * @return RequestConfig
     */
    fun ezsigndocumentGetEzsignannotationsV1RequestConfig(pkiEzsigndocumentID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/getEzsignannotations".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsigndocument&#39;s Ezsigndiscussions
     * 
     * @param pkiEzsigndocumentID 
     * @return EzsigndocumentGetEzsigndiscussionsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentGetEzsigndiscussionsV1(pkiEzsigndocumentID: kotlin.Int) : EzsigndocumentGetEzsigndiscussionsV1Response {
        val localVarResponse = ezsigndocumentGetEzsigndiscussionsV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetEzsigndiscussionsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsigndocument&#39;s Ezsigndiscussions
     * 
     * @param pkiEzsigndocumentID 
     * @return ApiResponse<EzsigndocumentGetEzsigndiscussionsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentGetEzsigndiscussionsV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int) : ApiResponse<EzsigndocumentGetEzsigndiscussionsV1Response?> {
        val localVariableConfig = ezsigndocumentGetEzsigndiscussionsV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return request<Unit, EzsigndocumentGetEzsigndiscussionsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetEzsigndiscussionsV1
     *
     * @param pkiEzsigndocumentID 
     * @return RequestConfig
     */
    fun ezsigndocumentGetEzsigndiscussionsV1RequestConfig(pkiEzsigndocumentID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/getEzsigndiscussions".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsigndocument&#39;s Ezsignformfieldgroups
     * 
     * @param pkiEzsigndocumentID 
     * @return EzsigndocumentGetEzsignformfieldgroupsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentGetEzsignformfieldgroupsV1(pkiEzsigndocumentID: kotlin.Int) : EzsigndocumentGetEzsignformfieldgroupsV1Response {
        val localVarResponse = ezsigndocumentGetEzsignformfieldgroupsV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetEzsignformfieldgroupsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsigndocument&#39;s Ezsignformfieldgroups
     * 
     * @param pkiEzsigndocumentID 
     * @return ApiResponse<EzsigndocumentGetEzsignformfieldgroupsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentGetEzsignformfieldgroupsV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int) : ApiResponse<EzsigndocumentGetEzsignformfieldgroupsV1Response?> {
        val localVariableConfig = ezsigndocumentGetEzsignformfieldgroupsV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return request<Unit, EzsigndocumentGetEzsignformfieldgroupsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetEzsignformfieldgroupsV1
     *
     * @param pkiEzsigndocumentID 
     * @return RequestConfig
     */
    fun ezsigndocumentGetEzsignformfieldgroupsV1RequestConfig(pkiEzsigndocumentID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/getEzsignformfieldgroups".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsigndocument&#39;s Ezsignpages
     * 
     * @param pkiEzsigndocumentID 
     * @return EzsigndocumentGetEzsignpagesV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentGetEzsignpagesV1(pkiEzsigndocumentID: kotlin.Int) : EzsigndocumentGetEzsignpagesV1Response {
        val localVarResponse = ezsigndocumentGetEzsignpagesV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetEzsignpagesV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsigndocument&#39;s Ezsignpages
     * 
     * @param pkiEzsigndocumentID 
     * @return ApiResponse<EzsigndocumentGetEzsignpagesV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentGetEzsignpagesV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int) : ApiResponse<EzsigndocumentGetEzsignpagesV1Response?> {
        val localVariableConfig = ezsigndocumentGetEzsignpagesV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return request<Unit, EzsigndocumentGetEzsignpagesV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetEzsignpagesV1
     *
     * @param pkiEzsigndocumentID 
     * @return RequestConfig
     */
    fun ezsigndocumentGetEzsignpagesV1RequestConfig(pkiEzsigndocumentID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/getEzsignpages".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsigndocument&#39;s automatic Ezsignsignatures
     * Return the Ezsignsignatures that can be signed by the current user at the current step in the process
     * @param pkiEzsigndocumentID 
     * @return EzsigndocumentGetEzsignsignaturesAutomaticV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentGetEzsignsignaturesAutomaticV1(pkiEzsigndocumentID: kotlin.Int) : EzsigndocumentGetEzsignsignaturesAutomaticV1Response {
        val localVarResponse = ezsigndocumentGetEzsignsignaturesAutomaticV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetEzsignsignaturesAutomaticV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsigndocument&#39;s automatic Ezsignsignatures
     * Return the Ezsignsignatures that can be signed by the current user at the current step in the process
     * @param pkiEzsigndocumentID 
     * @return ApiResponse<EzsigndocumentGetEzsignsignaturesAutomaticV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentGetEzsignsignaturesAutomaticV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int) : ApiResponse<EzsigndocumentGetEzsignsignaturesAutomaticV1Response?> {
        val localVariableConfig = ezsigndocumentGetEzsignsignaturesAutomaticV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return request<Unit, EzsigndocumentGetEzsignsignaturesAutomaticV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetEzsignsignaturesAutomaticV1
     *
     * @param pkiEzsigndocumentID 
     * @return RequestConfig
     */
    fun ezsigndocumentGetEzsignsignaturesAutomaticV1RequestConfig(pkiEzsigndocumentID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/getEzsignsignaturesAutomatic".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsigndocument&#39;s Ezsignsignatures
     * 
     * @param pkiEzsigndocumentID 
     * @return EzsigndocumentGetEzsignsignaturesV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentGetEzsignsignaturesV1(pkiEzsigndocumentID: kotlin.Int) : EzsigndocumentGetEzsignsignaturesV1Response {
        val localVarResponse = ezsigndocumentGetEzsignsignaturesV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetEzsignsignaturesV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsigndocument&#39;s Ezsignsignatures
     * 
     * @param pkiEzsigndocumentID 
     * @return ApiResponse<EzsigndocumentGetEzsignsignaturesV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentGetEzsignsignaturesV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int) : ApiResponse<EzsigndocumentGetEzsignsignaturesV1Response?> {
        val localVariableConfig = ezsigndocumentGetEzsignsignaturesV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return request<Unit, EzsigndocumentGetEzsignsignaturesV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetEzsignsignaturesV1
     *
     * @param pkiEzsigndocumentID 
     * @return RequestConfig
     */
    fun ezsigndocumentGetEzsignsignaturesV1RequestConfig(pkiEzsigndocumentID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/getEzsignsignatures".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsigndocument&#39;s Form Data
     * 
     * @param pkiEzsigndocumentID 
     * @return EzsigndocumentGetFormDataV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentGetFormDataV1(pkiEzsigndocumentID: kotlin.Int) : EzsigndocumentGetFormDataV1Response {
        val localVarResponse = ezsigndocumentGetFormDataV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetFormDataV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsigndocument&#39;s Form Data
     * 
     * @param pkiEzsigndocumentID 
     * @return ApiResponse<EzsigndocumentGetFormDataV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentGetFormDataV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int) : ApiResponse<EzsigndocumentGetFormDataV1Response?> {
        val localVariableConfig = ezsigndocumentGetFormDataV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return request<Unit, EzsigndocumentGetFormDataV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetFormDataV1
     *
     * @param pkiEzsigndocumentID 
     * @return RequestConfig
     */
    fun ezsigndocumentGetFormDataV1RequestConfig(pkiEzsigndocumentID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/getFormData".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsigndocument
     * 
     * @param pkiEzsigndocumentID 
     * @return EzsigndocumentGetObjectV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun ezsigndocumentGetObjectV1(pkiEzsigndocumentID: kotlin.Int) : EzsigndocumentGetObjectV1Response {
        @Suppress("DEPRECATION")
        val localVarResponse = ezsigndocumentGetObjectV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetObjectV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsigndocument
     * 
     * @param pkiEzsigndocumentID 
     * @return ApiResponse<EzsigndocumentGetObjectV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun ezsigndocumentGetObjectV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int) : ApiResponse<EzsigndocumentGetObjectV1Response?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = ezsigndocumentGetObjectV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return request<Unit, EzsigndocumentGetObjectV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetObjectV1
     *
     * @param pkiEzsigndocumentID 
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun ezsigndocumentGetObjectV1RequestConfig(pkiEzsigndocumentID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Ezsigndocument
     * 
     * @param pkiEzsigndocumentID 
     * @return EzsigndocumentGetObjectV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentGetObjectV2(pkiEzsigndocumentID: kotlin.Int) : EzsigndocumentGetObjectV2Response {
        val localVarResponse = ezsigndocumentGetObjectV2WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetObjectV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Ezsigndocument
     * 
     * @param pkiEzsigndocumentID 
     * @return ApiResponse<EzsigndocumentGetObjectV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentGetObjectV2WithHttpInfo(pkiEzsigndocumentID: kotlin.Int) : ApiResponse<EzsigndocumentGetObjectV2Response?> {
        val localVariableConfig = ezsigndocumentGetObjectV2RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return request<Unit, EzsigndocumentGetObjectV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetObjectV2
     *
     * @param pkiEzsigndocumentID 
     * @return RequestConfig
     */
    fun ezsigndocumentGetObjectV2RequestConfig(pkiEzsigndocumentID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/object/ezsigndocument/{pkiEzsigndocumentID}".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve the temporary proof
     * Retrieve the temporary proof while the Ezsigndocument is being processed since the proof isn&#39;t available until the Ezsigndocument is completed
     * @param pkiEzsigndocumentID 
     * @return EzsigndocumentGetTemporaryProofV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentGetTemporaryProofV1(pkiEzsigndocumentID: kotlin.Int) : EzsigndocumentGetTemporaryProofV1Response {
        val localVarResponse = ezsigndocumentGetTemporaryProofV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetTemporaryProofV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve the temporary proof
     * Retrieve the temporary proof while the Ezsigndocument is being processed since the proof isn&#39;t available until the Ezsigndocument is completed
     * @param pkiEzsigndocumentID 
     * @return ApiResponse<EzsigndocumentGetTemporaryProofV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentGetTemporaryProofV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int) : ApiResponse<EzsigndocumentGetTemporaryProofV1Response?> {
        val localVariableConfig = ezsigndocumentGetTemporaryProofV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID)

        return request<Unit, EzsigndocumentGetTemporaryProofV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetTemporaryProofV1
     *
     * @param pkiEzsigndocumentID 
     * @return RequestConfig
     */
    fun ezsigndocumentGetTemporaryProofV1RequestConfig(pkiEzsigndocumentID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/getTemporaryProof".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve positions X,Y of given words from a Ezsigndocument
     * 
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentGetWordsPositionsV1Request 
     * @return EzsigndocumentGetWordsPositionsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentGetWordsPositionsV1(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentGetWordsPositionsV1Request: EzsigndocumentGetWordsPositionsV1Request) : EzsigndocumentGetWordsPositionsV1Response {
        val localVarResponse = ezsigndocumentGetWordsPositionsV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentGetWordsPositionsV1Request = ezsigndocumentGetWordsPositionsV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentGetWordsPositionsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve positions X,Y of given words from a Ezsigndocument
     * 
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentGetWordsPositionsV1Request 
     * @return ApiResponse<EzsigndocumentGetWordsPositionsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentGetWordsPositionsV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentGetWordsPositionsV1Request: EzsigndocumentGetWordsPositionsV1Request) : ApiResponse<EzsigndocumentGetWordsPositionsV1Response?> {
        val localVariableConfig = ezsigndocumentGetWordsPositionsV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentGetWordsPositionsV1Request = ezsigndocumentGetWordsPositionsV1Request)

        return request<EzsigndocumentGetWordsPositionsV1Request, EzsigndocumentGetWordsPositionsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentGetWordsPositionsV1
     *
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentGetWordsPositionsV1Request 
     * @return RequestConfig
     */
    fun ezsigndocumentGetWordsPositionsV1RequestConfig(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentGetWordsPositionsV1Request: EzsigndocumentGetWordsPositionsV1Request) : RequestConfig<EzsigndocumentGetWordsPositionsV1Request> {
        val localVariableBody = ezsigndocumentGetWordsPositionsV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/getWordsPositions".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Patch an existing Ezsigndocument
     * 
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentPatchObjectV1Request 
     * @return EzsigndocumentPatchObjectV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentPatchObjectV1(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentPatchObjectV1Request: EzsigndocumentPatchObjectV1Request) : EzsigndocumentPatchObjectV1Response {
        val localVarResponse = ezsigndocumentPatchObjectV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentPatchObjectV1Request = ezsigndocumentPatchObjectV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentPatchObjectV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Patch an existing Ezsigndocument
     * 
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentPatchObjectV1Request 
     * @return ApiResponse<EzsigndocumentPatchObjectV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentPatchObjectV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentPatchObjectV1Request: EzsigndocumentPatchObjectV1Request) : ApiResponse<EzsigndocumentPatchObjectV1Response?> {
        val localVariableConfig = ezsigndocumentPatchObjectV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentPatchObjectV1Request = ezsigndocumentPatchObjectV1Request)

        return request<EzsigndocumentPatchObjectV1Request, EzsigndocumentPatchObjectV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentPatchObjectV1
     *
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentPatchObjectV1Request 
     * @return RequestConfig
     */
    fun ezsigndocumentPatchObjectV1RequestConfig(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentPatchObjectV1Request: EzsigndocumentPatchObjectV1Request) : RequestConfig<EzsigndocumentPatchObjectV1Request> {
        val localVariableBody = ezsigndocumentPatchObjectV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Submit the Ezsignform
     * 
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentSubmitEzsignformV1Request 
     * @return EzsigndocumentSubmitEzsignformV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentSubmitEzsignformV1(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentSubmitEzsignformV1Request: EzsigndocumentSubmitEzsignformV1Request) : EzsigndocumentSubmitEzsignformV1Response {
        val localVarResponse = ezsigndocumentSubmitEzsignformV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentSubmitEzsignformV1Request = ezsigndocumentSubmitEzsignformV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentSubmitEzsignformV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Submit the Ezsignform
     * 
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentSubmitEzsignformV1Request 
     * @return ApiResponse<EzsigndocumentSubmitEzsignformV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentSubmitEzsignformV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentSubmitEzsignformV1Request: EzsigndocumentSubmitEzsignformV1Request) : ApiResponse<EzsigndocumentSubmitEzsignformV1Response?> {
        val localVariableConfig = ezsigndocumentSubmitEzsignformV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID, ezsigndocumentSubmitEzsignformV1Request = ezsigndocumentSubmitEzsignformV1Request)

        return request<EzsigndocumentSubmitEzsignformV1Request, EzsigndocumentSubmitEzsignformV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentSubmitEzsignformV1
     *
     * @param pkiEzsigndocumentID 
     * @param ezsigndocumentSubmitEzsignformV1Request 
     * @return RequestConfig
     */
    fun ezsigndocumentSubmitEzsignformV1RequestConfig(pkiEzsigndocumentID: kotlin.Int, ezsigndocumentSubmitEzsignformV1Request: EzsigndocumentSubmitEzsignformV1Request) : RequestConfig<EzsigndocumentSubmitEzsignformV1Request> {
        val localVariableBody = ezsigndocumentSubmitEzsignformV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/submitEzsignform".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Unsend the Ezsigndocument
     * Once an Ezsigndocument has been sent to signatories, it cannot be modified.  Using this endpoint, you can unsend the Ezsigndocument and make it modifiable again.  Signatories will receive an email informing them the signature process was aborted and they might receive a new invitation to sign.   Warning: Any signature previously made by signatories on this Ezsigndocumentswill be lost.
     * @param pkiEzsigndocumentID 
     * @param body 
     * @return EzsigndocumentUnsendV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ezsigndocumentUnsendV1(pkiEzsigndocumentID: kotlin.Int, body: kotlin.Any) : EzsigndocumentUnsendV1Response {
        val localVarResponse = ezsigndocumentUnsendV1WithHttpInfo(pkiEzsigndocumentID = pkiEzsigndocumentID, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EzsigndocumentUnsendV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Unsend the Ezsigndocument
     * Once an Ezsigndocument has been sent to signatories, it cannot be modified.  Using this endpoint, you can unsend the Ezsigndocument and make it modifiable again.  Signatories will receive an email informing them the signature process was aborted and they might receive a new invitation to sign.   Warning: Any signature previously made by signatories on this Ezsigndocumentswill be lost.
     * @param pkiEzsigndocumentID 
     * @param body 
     * @return ApiResponse<EzsigndocumentUnsendV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ezsigndocumentUnsendV1WithHttpInfo(pkiEzsigndocumentID: kotlin.Int, body: kotlin.Any) : ApiResponse<EzsigndocumentUnsendV1Response?> {
        val localVariableConfig = ezsigndocumentUnsendV1RequestConfig(pkiEzsigndocumentID = pkiEzsigndocumentID, body = body)

        return request<kotlin.Any, EzsigndocumentUnsendV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ezsigndocumentUnsendV1
     *
     * @param pkiEzsigndocumentID 
     * @param body 
     * @return RequestConfig
     */
    fun ezsigndocumentUnsendV1RequestConfig(pkiEzsigndocumentID: kotlin.Int, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/ezsigndocument/{pkiEzsigndocumentID}/unsend".replace("{"+"pkiEzsigndocumentID"+"}", encodeURIComponent(pkiEzsigndocumentID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
