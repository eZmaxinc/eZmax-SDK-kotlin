/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package eZmaxApi.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import eZmaxApi.models.CommonResponseError
import eZmaxApi.models.HeaderAcceptLanguage
import eZmaxApi.models.UserCreateObjectV1Request
import eZmaxApi.models.UserCreateObjectV1Response
import eZmaxApi.models.UserCreateObjectV2Request
import eZmaxApi.models.UserCreateObjectV2Response
import eZmaxApi.models.UserEditObjectV1Request
import eZmaxApi.models.UserEditObjectV1Response
import eZmaxApi.models.UserEditPermissionsV1Request
import eZmaxApi.models.UserEditPermissionsV1Response
import eZmaxApi.models.UserGetApikeysV1Response
import eZmaxApi.models.UserGetAutocompleteV2Response
import eZmaxApi.models.UserGetEffectivePermissionsV1Response
import eZmaxApi.models.UserGetListV1Response
import eZmaxApi.models.UserGetObjectV2Response
import eZmaxApi.models.UserGetPermissionsV1Response
import eZmaxApi.models.UserGetSubnetsV1Response
import eZmaxApi.models.UserGetUsergroupexternalsV1Response
import eZmaxApi.models.UserGetUsergroupsV1Response
import eZmaxApi.models.UserSendPasswordResetV1Response

import com.squareup.moshi.Json

import eZmaxApi.infrastructure.ApiClient
import eZmaxApi.infrastructure.ApiResponse
import eZmaxApi.infrastructure.ClientException
import eZmaxApi.infrastructure.ClientError
import eZmaxApi.infrastructure.ServerException
import eZmaxApi.infrastructure.ServerError
import eZmaxApi.infrastructure.MultiValueMap
import eZmaxApi.infrastructure.PartConfig
import eZmaxApi.infrastructure.RequestConfig
import eZmaxApi.infrastructure.RequestMethod
import eZmaxApi.infrastructure.ResponseType
import eZmaxApi.infrastructure.Success
import eZmaxApi.infrastructure.toMultiValue

class ObjectUserApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://prod.api.appcluster01.ca-central-1.ezmax.com/rest")
        }
    }

    /**
     * Create a new User
     * The endpoint allows to create one or many elements at once.
     * @param userCreateObjectV1Request 
     * @return UserCreateObjectV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userCreateObjectV1(userCreateObjectV1Request: UserCreateObjectV1Request) : UserCreateObjectV1Response {
        val localVarResponse = userCreateObjectV1WithHttpInfo(userCreateObjectV1Request = userCreateObjectV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserCreateObjectV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a new User
     * The endpoint allows to create one or many elements at once.
     * @param userCreateObjectV1Request 
     * @return ApiResponse<UserCreateObjectV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userCreateObjectV1WithHttpInfo(userCreateObjectV1Request: UserCreateObjectV1Request) : ApiResponse<UserCreateObjectV1Response?> {
        val localVariableConfig = userCreateObjectV1RequestConfig(userCreateObjectV1Request = userCreateObjectV1Request)

        return request<UserCreateObjectV1Request, UserCreateObjectV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userCreateObjectV1
     *
     * @param userCreateObjectV1Request 
     * @return RequestConfig
     */
    fun userCreateObjectV1RequestConfig(userCreateObjectV1Request: UserCreateObjectV1Request) : RequestConfig<UserCreateObjectV1Request> {
        val localVariableBody = userCreateObjectV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/user",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create a new User
     * The endpoint allows to create one or many elements at once.
     * @param userCreateObjectV2Request 
     * @return UserCreateObjectV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userCreateObjectV2(userCreateObjectV2Request: UserCreateObjectV2Request) : UserCreateObjectV2Response {
        val localVarResponse = userCreateObjectV2WithHttpInfo(userCreateObjectV2Request = userCreateObjectV2Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserCreateObjectV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a new User
     * The endpoint allows to create one or many elements at once.
     * @param userCreateObjectV2Request 
     * @return ApiResponse<UserCreateObjectV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userCreateObjectV2WithHttpInfo(userCreateObjectV2Request: UserCreateObjectV2Request) : ApiResponse<UserCreateObjectV2Response?> {
        val localVariableConfig = userCreateObjectV2RequestConfig(userCreateObjectV2Request = userCreateObjectV2Request)

        return request<UserCreateObjectV2Request, UserCreateObjectV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userCreateObjectV2
     *
     * @param userCreateObjectV2Request 
     * @return RequestConfig
     */
    fun userCreateObjectV2RequestConfig(userCreateObjectV2Request: UserCreateObjectV2Request) : RequestConfig<UserCreateObjectV2Request> {
        val localVariableBody = userCreateObjectV2Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/2/object/user",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Edit an existing User
     * 
     * @param pkiUserID The unique ID of the User
     * @param userEditObjectV1Request 
     * @return UserEditObjectV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userEditObjectV1(pkiUserID: kotlin.Int, userEditObjectV1Request: UserEditObjectV1Request) : UserEditObjectV1Response {
        val localVarResponse = userEditObjectV1WithHttpInfo(pkiUserID = pkiUserID, userEditObjectV1Request = userEditObjectV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserEditObjectV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Edit an existing User
     * 
     * @param pkiUserID The unique ID of the User
     * @param userEditObjectV1Request 
     * @return ApiResponse<UserEditObjectV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userEditObjectV1WithHttpInfo(pkiUserID: kotlin.Int, userEditObjectV1Request: UserEditObjectV1Request) : ApiResponse<UserEditObjectV1Response?> {
        val localVariableConfig = userEditObjectV1RequestConfig(pkiUserID = pkiUserID, userEditObjectV1Request = userEditObjectV1Request)

        return request<UserEditObjectV1Request, UserEditObjectV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userEditObjectV1
     *
     * @param pkiUserID The unique ID of the User
     * @param userEditObjectV1Request 
     * @return RequestConfig
     */
    fun userEditObjectV1RequestConfig(pkiUserID: kotlin.Int, userEditObjectV1Request: UserEditObjectV1Request) : RequestConfig<UserEditObjectV1Request> {
        val localVariableBody = userEditObjectV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/1/object/user/{pkiUserID}".replace("{"+"pkiUserID"+"}", encodeURIComponent(pkiUserID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Edit multiple Permissions
     * Using this endpoint, you can edit multiple Permissions at the same time.
     * @param pkiUserID 
     * @param userEditPermissionsV1Request 
     * @return UserEditPermissionsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userEditPermissionsV1(pkiUserID: kotlin.Int, userEditPermissionsV1Request: UserEditPermissionsV1Request) : UserEditPermissionsV1Response {
        val localVarResponse = userEditPermissionsV1WithHttpInfo(pkiUserID = pkiUserID, userEditPermissionsV1Request = userEditPermissionsV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserEditPermissionsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Edit multiple Permissions
     * Using this endpoint, you can edit multiple Permissions at the same time.
     * @param pkiUserID 
     * @param userEditPermissionsV1Request 
     * @return ApiResponse<UserEditPermissionsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userEditPermissionsV1WithHttpInfo(pkiUserID: kotlin.Int, userEditPermissionsV1Request: UserEditPermissionsV1Request) : ApiResponse<UserEditPermissionsV1Response?> {
        val localVariableConfig = userEditPermissionsV1RequestConfig(pkiUserID = pkiUserID, userEditPermissionsV1Request = userEditPermissionsV1Request)

        return request<UserEditPermissionsV1Request, UserEditPermissionsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userEditPermissionsV1
     *
     * @param pkiUserID 
     * @param userEditPermissionsV1Request 
     * @return RequestConfig
     */
    fun userEditPermissionsV1RequestConfig(pkiUserID: kotlin.Int, userEditPermissionsV1Request: UserEditPermissionsV1Request) : RequestConfig<UserEditPermissionsV1Request> {
        val localVariableBody = userEditPermissionsV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/1/object/user/{pkiUserID}/editPermissions".replace("{"+"pkiUserID"+"}", encodeURIComponent(pkiUserID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing User&#39;s Apikeys
     * 
     * @param pkiUserID 
     * @return UserGetApikeysV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userGetApikeysV1(pkiUserID: kotlin.Int) : UserGetApikeysV1Response {
        val localVarResponse = userGetApikeysV1WithHttpInfo(pkiUserID = pkiUserID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserGetApikeysV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing User&#39;s Apikeys
     * 
     * @param pkiUserID 
     * @return ApiResponse<UserGetApikeysV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userGetApikeysV1WithHttpInfo(pkiUserID: kotlin.Int) : ApiResponse<UserGetApikeysV1Response?> {
        val localVariableConfig = userGetApikeysV1RequestConfig(pkiUserID = pkiUserID)

        return request<Unit, UserGetApikeysV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userGetApikeysV1
     *
     * @param pkiUserID 
     * @return RequestConfig
     */
    fun userGetApikeysV1RequestConfig(pkiUserID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/user/{pkiUserID}/getApikeys".replace("{"+"pkiUserID"+"}", encodeURIComponent(pkiUserID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sSelector
     */
     enum class SSelectorUserGetAutocompleteV2(val value: kotlin.String) {
         @Json(name = "AgentBrokerEmployeeEzsignUserNormal") AgentBrokerEmployeeEzsignUserNormal("AgentBrokerEmployeeEzsignUserNormal"),
         @Json(name = "AgentBrokerEmployeeNormalBuiltIn") AgentBrokerEmployeeNormalBuiltIn("AgentBrokerEmployeeNormalBuiltIn"),
         @Json(name = "AgentBrokerEzsignuserNormal") AgentBrokerEzsignuserNormal("AgentBrokerEzsignuserNormal"),
         @Json(name = "ClonableUsers") ClonableUsers("ClonableUsers"),
         @Json(name = "EzsignuserBuiltIn") EzsignuserBuiltIn("EzsignuserBuiltIn"),
         @Json(name = "Normal") Normal("Normal"),
         @Json(name = "UsergroupDelegated") UsergroupDelegated("UsergroupDelegated")
     }

    /**
     * enum for parameter eFilterActive
     */
     enum class EFilterActiveUserGetAutocompleteV2(val value: kotlin.String) {
         @Json(name = "All") All("All"),
         @Json(name = "Active") Active("Active"),
         @Json(name = "Inactive") Inactive("Inactive")
     }

    /**
     * Retrieve Users and IDs
     * Get the list of User to be used in a dropdown or autocomplete control.
     * @param sSelector The type of Users to return
     * @param eFilterActive Specify which results we want to display. (optional, default to Active)
     * @param sQuery Allow to filter the returned results (optional)
     * @param acceptLanguage  (optional)
     * @return UserGetAutocompleteV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userGetAutocompleteV2(sSelector: SSelectorUserGetAutocompleteV2, eFilterActive: EFilterActiveUserGetAutocompleteV2? = EFilterActiveUserGetAutocompleteV2.Active, sQuery: kotlin.String? = null, acceptLanguage: HeaderAcceptLanguage? = null) : UserGetAutocompleteV2Response {
        val localVarResponse = userGetAutocompleteV2WithHttpInfo(sSelector = sSelector, eFilterActive = eFilterActive, sQuery = sQuery, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserGetAutocompleteV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve Users and IDs
     * Get the list of User to be used in a dropdown or autocomplete control.
     * @param sSelector The type of Users to return
     * @param eFilterActive Specify which results we want to display. (optional, default to Active)
     * @param sQuery Allow to filter the returned results (optional)
     * @param acceptLanguage  (optional)
     * @return ApiResponse<UserGetAutocompleteV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userGetAutocompleteV2WithHttpInfo(sSelector: SSelectorUserGetAutocompleteV2, eFilterActive: EFilterActiveUserGetAutocompleteV2?, sQuery: kotlin.String?, acceptLanguage: HeaderAcceptLanguage?) : ApiResponse<UserGetAutocompleteV2Response?> {
        val localVariableConfig = userGetAutocompleteV2RequestConfig(sSelector = sSelector, eFilterActive = eFilterActive, sQuery = sQuery, acceptLanguage = acceptLanguage)

        return request<Unit, UserGetAutocompleteV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userGetAutocompleteV2
     *
     * @param sSelector The type of Users to return
     * @param eFilterActive Specify which results we want to display. (optional, default to Active)
     * @param sQuery Allow to filter the returned results (optional)
     * @param acceptLanguage  (optional)
     * @return RequestConfig
     */
    fun userGetAutocompleteV2RequestConfig(sSelector: SSelectorUserGetAutocompleteV2, eFilterActive: EFilterActiveUserGetAutocompleteV2?, sQuery: kotlin.String?, acceptLanguage: HeaderAcceptLanguage?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (eFilterActive != null) {
                    put("eFilterActive", listOf(eFilterActive.value))
                }
                if (sQuery != null) {
                    put("sQuery", listOf(sQuery.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/object/user/getAutocomplete/{sSelector}".replace("{"+"sSelector"+"}", encodeURIComponent(sSelector.value.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing User&#39;s Effective Permissions
     * Effective Permissions refers to the combination of Permissions held by a User and the Permissions associated with the Usergroups they belong to.
     * @param pkiUserID 
     * @return UserGetEffectivePermissionsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userGetEffectivePermissionsV1(pkiUserID: kotlin.Int) : UserGetEffectivePermissionsV1Response {
        val localVarResponse = userGetEffectivePermissionsV1WithHttpInfo(pkiUserID = pkiUserID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserGetEffectivePermissionsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing User&#39;s Effective Permissions
     * Effective Permissions refers to the combination of Permissions held by a User and the Permissions associated with the Usergroups they belong to.
     * @param pkiUserID 
     * @return ApiResponse<UserGetEffectivePermissionsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userGetEffectivePermissionsV1WithHttpInfo(pkiUserID: kotlin.Int) : ApiResponse<UserGetEffectivePermissionsV1Response?> {
        val localVariableConfig = userGetEffectivePermissionsV1RequestConfig(pkiUserID = pkiUserID)

        return request<Unit, UserGetEffectivePermissionsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userGetEffectivePermissionsV1
     *
     * @param pkiUserID 
     * @return RequestConfig
     */
    fun userGetEffectivePermissionsV1RequestConfig(pkiUserID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/user/{pkiUserID}/getEffectivePermissions".replace("{"+"pkiUserID"+"}", encodeURIComponent(pkiUserID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter eOrderBy
     */
     enum class EOrderByUserGetListV1(val value: kotlin.String) {
         @Json(name = "pkiUserID_ASC") pkiUserID_ASC("pkiUserID_ASC"),
         @Json(name = "pkiUserID_DESC") pkiUserID_DESC("pkiUserID_DESC"),
         @Json(name = "sUserFirstname_ASC") sUserFirstname_ASC("sUserFirstname_ASC"),
         @Json(name = "sUserFirstname_DESC") sUserFirstname_DESC("sUserFirstname_DESC"),
         @Json(name = "sUserLastname_ASC") sUserLastname_ASC("sUserLastname_ASC"),
         @Json(name = "sUserLastname_DESC") sUserLastname_DESC("sUserLastname_DESC"),
         @Json(name = "sUserLoginname_ASC") sUserLoginname_ASC("sUserLoginname_ASC"),
         @Json(name = "sUserLoginname_DESC") sUserLoginname_DESC("sUserLoginname_DESC"),
         @Json(name = "bUserIsactive_ASC") bUserIsactive_ASC("bUserIsactive_ASC"),
         @Json(name = "bUserIsactive_DESC") bUserIsactive_DESC("bUserIsactive_DESC"),
         @Json(name = "eUserType_ASC") eUserType_ASC("eUserType_ASC"),
         @Json(name = "eUserType_DESC") eUserType_DESC("eUserType_DESC"),
         @Json(name = "eUserOrigin_ASC") eUserOrigin_ASC("eUserOrigin_ASC"),
         @Json(name = "eUserOrigin_DESC") eUserOrigin_DESC("eUserOrigin_DESC"),
         @Json(name = "eUserEzsignaccess_ASC") eUserEzsignaccess_ASC("eUserEzsignaccess_ASC"),
         @Json(name = "eUserEzsignaccess_DESC") eUserEzsignaccess_DESC("eUserEzsignaccess_DESC"),
         @Json(name = "dtUserEzsignprepaidexpiration_ASC") dtUserEzsignprepaidexpiration_ASC("dtUserEzsignprepaidexpiration_ASC"),
         @Json(name = "dtUserEzsignprepaidexpiration_DESC") dtUserEzsignprepaidexpiration_DESC("dtUserEzsignprepaidexpiration_DESC"),
         @Json(name = "sEmailAddress_ASC") sEmailAddress_ASC("sEmailAddress_ASC"),
         @Json(name = "sEmailAddress_DESC") sEmailAddress_DESC("sEmailAddress_DESC")
     }

    /**
     * Retrieve User list
     * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eUserType | AgentBroker&lt;br&gt;Assistant&lt;br&gt;Employee&lt;br&gt;EzsignUser&lt;br&gt;Normal | | eUserOrigin | BuiltIn&lt;br&gt;External | | eUserEzsignaccess | No&lt;br&gt;PaidByOffice&lt;br&gt;PerDocument&lt;br&gt;Prepaid |
     * @param eOrderBy Specify how you want the results to be sorted (optional)
     * @param iRowMax  (optional)
     * @param iRowOffset  (optional, default to 0)
     * @param acceptLanguage  (optional)
     * @param sFilter  (optional)
     * @return UserGetListV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userGetListV1(eOrderBy: EOrderByUserGetListV1? = null, iRowMax: kotlin.Int? = null, iRowOffset: kotlin.Int? = 0, acceptLanguage: HeaderAcceptLanguage? = null, sFilter: kotlin.String? = null) : UserGetListV1Response {
        val localVarResponse = userGetListV1WithHttpInfo(eOrderBy = eOrderBy, iRowMax = iRowMax, iRowOffset = iRowOffset, acceptLanguage = acceptLanguage, sFilter = sFilter)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserGetListV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve User list
     * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eUserType | AgentBroker&lt;br&gt;Assistant&lt;br&gt;Employee&lt;br&gt;EzsignUser&lt;br&gt;Normal | | eUserOrigin | BuiltIn&lt;br&gt;External | | eUserEzsignaccess | No&lt;br&gt;PaidByOffice&lt;br&gt;PerDocument&lt;br&gt;Prepaid |
     * @param eOrderBy Specify how you want the results to be sorted (optional)
     * @param iRowMax  (optional)
     * @param iRowOffset  (optional, default to 0)
     * @param acceptLanguage  (optional)
     * @param sFilter  (optional)
     * @return ApiResponse<UserGetListV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userGetListV1WithHttpInfo(eOrderBy: EOrderByUserGetListV1?, iRowMax: kotlin.Int?, iRowOffset: kotlin.Int?, acceptLanguage: HeaderAcceptLanguage?, sFilter: kotlin.String?) : ApiResponse<UserGetListV1Response?> {
        val localVariableConfig = userGetListV1RequestConfig(eOrderBy = eOrderBy, iRowMax = iRowMax, iRowOffset = iRowOffset, acceptLanguage = acceptLanguage, sFilter = sFilter)

        return request<Unit, UserGetListV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userGetListV1
     *
     * @param eOrderBy Specify how you want the results to be sorted (optional)
     * @param iRowMax  (optional)
     * @param iRowOffset  (optional, default to 0)
     * @param acceptLanguage  (optional)
     * @param sFilter  (optional)
     * @return RequestConfig
     */
    fun userGetListV1RequestConfig(eOrderBy: EOrderByUserGetListV1?, iRowMax: kotlin.Int?, iRowOffset: kotlin.Int?, acceptLanguage: HeaderAcceptLanguage?, sFilter: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (eOrderBy != null) {
                    put("eOrderBy", listOf(eOrderBy.value))
                }
                if (iRowMax != null) {
                    put("iRowMax", listOf(iRowMax.toString()))
                }
                if (iRowOffset != null) {
                    put("iRowOffset", listOf(iRowOffset.toString()))
                }
                if (sFilter != null) {
                    put("sFilter", listOf(sFilter.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/user/getList",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing User
     * 
     * @param pkiUserID The unique ID of the User
     * @return UserGetObjectV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userGetObjectV2(pkiUserID: kotlin.Int) : UserGetObjectV2Response {
        val localVarResponse = userGetObjectV2WithHttpInfo(pkiUserID = pkiUserID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserGetObjectV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing User
     * 
     * @param pkiUserID The unique ID of the User
     * @return ApiResponse<UserGetObjectV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userGetObjectV2WithHttpInfo(pkiUserID: kotlin.Int) : ApiResponse<UserGetObjectV2Response?> {
        val localVariableConfig = userGetObjectV2RequestConfig(pkiUserID = pkiUserID)

        return request<Unit, UserGetObjectV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userGetObjectV2
     *
     * @param pkiUserID The unique ID of the User
     * @return RequestConfig
     */
    fun userGetObjectV2RequestConfig(pkiUserID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/object/user/{pkiUserID}".replace("{"+"pkiUserID"+"}", encodeURIComponent(pkiUserID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing User&#39;s Permissions
     * 
     * @param pkiUserID 
     * @return UserGetPermissionsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userGetPermissionsV1(pkiUserID: kotlin.Int) : UserGetPermissionsV1Response {
        val localVarResponse = userGetPermissionsV1WithHttpInfo(pkiUserID = pkiUserID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserGetPermissionsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing User&#39;s Permissions
     * 
     * @param pkiUserID 
     * @return ApiResponse<UserGetPermissionsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userGetPermissionsV1WithHttpInfo(pkiUserID: kotlin.Int) : ApiResponse<UserGetPermissionsV1Response?> {
        val localVariableConfig = userGetPermissionsV1RequestConfig(pkiUserID = pkiUserID)

        return request<Unit, UserGetPermissionsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userGetPermissionsV1
     *
     * @param pkiUserID 
     * @return RequestConfig
     */
    fun userGetPermissionsV1RequestConfig(pkiUserID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/user/{pkiUserID}/getPermissions".replace("{"+"pkiUserID"+"}", encodeURIComponent(pkiUserID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing User&#39;s Subnets
     * 
     * @param pkiUserID 
     * @return UserGetSubnetsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userGetSubnetsV1(pkiUserID: kotlin.Int) : UserGetSubnetsV1Response {
        val localVarResponse = userGetSubnetsV1WithHttpInfo(pkiUserID = pkiUserID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserGetSubnetsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing User&#39;s Subnets
     * 
     * @param pkiUserID 
     * @return ApiResponse<UserGetSubnetsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userGetSubnetsV1WithHttpInfo(pkiUserID: kotlin.Int) : ApiResponse<UserGetSubnetsV1Response?> {
        val localVariableConfig = userGetSubnetsV1RequestConfig(pkiUserID = pkiUserID)

        return request<Unit, UserGetSubnetsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userGetSubnetsV1
     *
     * @param pkiUserID 
     * @return RequestConfig
     */
    fun userGetSubnetsV1RequestConfig(pkiUserID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/user/{pkiUserID}/getSubnets".replace("{"+"pkiUserID"+"}", encodeURIComponent(pkiUserID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get User&#39;s Usergroupexternals
     * 
     * @param pkiUserID 
     * @return UserGetUsergroupexternalsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userGetUsergroupexternalsV1(pkiUserID: kotlin.Int) : UserGetUsergroupexternalsV1Response {
        val localVarResponse = userGetUsergroupexternalsV1WithHttpInfo(pkiUserID = pkiUserID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserGetUsergroupexternalsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get User&#39;s Usergroupexternals
     * 
     * @param pkiUserID 
     * @return ApiResponse<UserGetUsergroupexternalsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userGetUsergroupexternalsV1WithHttpInfo(pkiUserID: kotlin.Int) : ApiResponse<UserGetUsergroupexternalsV1Response?> {
        val localVariableConfig = userGetUsergroupexternalsV1RequestConfig(pkiUserID = pkiUserID)

        return request<Unit, UserGetUsergroupexternalsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userGetUsergroupexternalsV1
     *
     * @param pkiUserID 
     * @return RequestConfig
     */
    fun userGetUsergroupexternalsV1RequestConfig(pkiUserID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/user/{pkiUserID}/getUsergroupexternals".replace("{"+"pkiUserID"+"}", encodeURIComponent(pkiUserID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get User&#39;s Usergroups
     * 
     * @param pkiUserID 
     * @return UserGetUsergroupsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userGetUsergroupsV1(pkiUserID: kotlin.Int) : UserGetUsergroupsV1Response {
        val localVarResponse = userGetUsergroupsV1WithHttpInfo(pkiUserID = pkiUserID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserGetUsergroupsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get User&#39;s Usergroups
     * 
     * @param pkiUserID 
     * @return ApiResponse<UserGetUsergroupsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userGetUsergroupsV1WithHttpInfo(pkiUserID: kotlin.Int) : ApiResponse<UserGetUsergroupsV1Response?> {
        val localVariableConfig = userGetUsergroupsV1RequestConfig(pkiUserID = pkiUserID)

        return request<Unit, UserGetUsergroupsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userGetUsergroupsV1
     *
     * @param pkiUserID 
     * @return RequestConfig
     */
    fun userGetUsergroupsV1RequestConfig(pkiUserID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/user/{pkiUserID}/getUsergroups".replace("{"+"pkiUserID"+"}", encodeURIComponent(pkiUserID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Send password reset
     * Send the password reset email
     * @param pkiUserID 
     * @param body 
     * @return UserSendPasswordResetV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userSendPasswordResetV1(pkiUserID: kotlin.Int, body: kotlin.Any) : UserSendPasswordResetV1Response {
        val localVarResponse = userSendPasswordResetV1WithHttpInfo(pkiUserID = pkiUserID, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSendPasswordResetV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Send password reset
     * Send the password reset email
     * @param pkiUserID 
     * @param body 
     * @return ApiResponse<UserSendPasswordResetV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userSendPasswordResetV1WithHttpInfo(pkiUserID: kotlin.Int, body: kotlin.Any) : ApiResponse<UserSendPasswordResetV1Response?> {
        val localVariableConfig = userSendPasswordResetV1RequestConfig(pkiUserID = pkiUserID, body = body)

        return request<kotlin.Any, UserSendPasswordResetV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userSendPasswordResetV1
     *
     * @param pkiUserID 
     * @param body 
     * @return RequestConfig
     */
    fun userSendPasswordResetV1RequestConfig(pkiUserID: kotlin.Int, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/user/{pkiUserID}/sendPasswordReset".replace("{"+"pkiUserID"+"}", encodeURIComponent(pkiUserID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
