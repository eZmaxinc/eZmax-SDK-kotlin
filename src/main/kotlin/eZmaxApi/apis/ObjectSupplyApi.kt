/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package eZmaxApi.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import eZmaxApi.models.CommonResponseError
import eZmaxApi.models.HeaderAcceptLanguage
import eZmaxApi.models.SupplyCreateObjectV1Request
import eZmaxApi.models.SupplyCreateObjectV1Response
import eZmaxApi.models.SupplyDeleteObjectV1Response
import eZmaxApi.models.SupplyEditObjectV1Request
import eZmaxApi.models.SupplyEditObjectV1Response
import eZmaxApi.models.SupplyGetAutocompleteV2Response
import eZmaxApi.models.SupplyGetListV1Response
import eZmaxApi.models.SupplyGetObjectV2Response

import com.squareup.moshi.Json

import eZmaxApi.infrastructure.ApiClient
import eZmaxApi.infrastructure.ApiResponse
import eZmaxApi.infrastructure.ClientException
import eZmaxApi.infrastructure.ClientError
import eZmaxApi.infrastructure.ServerException
import eZmaxApi.infrastructure.ServerError
import eZmaxApi.infrastructure.MultiValueMap
import eZmaxApi.infrastructure.PartConfig
import eZmaxApi.infrastructure.RequestConfig
import eZmaxApi.infrastructure.RequestMethod
import eZmaxApi.infrastructure.ResponseType
import eZmaxApi.infrastructure.Success
import eZmaxApi.infrastructure.toMultiValue

class ObjectSupplyApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://prod.api.appcluster01.ca-central-1.ezmax.com/rest")
        }
    }

    /**
     * Create a new Supply
     * The endpoint allows to create one or many elements at once.
     * @param supplyCreateObjectV1Request 
     * @return SupplyCreateObjectV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun supplyCreateObjectV1(supplyCreateObjectV1Request: SupplyCreateObjectV1Request) : SupplyCreateObjectV1Response {
        val localVarResponse = supplyCreateObjectV1WithHttpInfo(supplyCreateObjectV1Request = supplyCreateObjectV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SupplyCreateObjectV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a new Supply
     * The endpoint allows to create one or many elements at once.
     * @param supplyCreateObjectV1Request 
     * @return ApiResponse<SupplyCreateObjectV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun supplyCreateObjectV1WithHttpInfo(supplyCreateObjectV1Request: SupplyCreateObjectV1Request) : ApiResponse<SupplyCreateObjectV1Response?> {
        val localVariableConfig = supplyCreateObjectV1RequestConfig(supplyCreateObjectV1Request = supplyCreateObjectV1Request)

        return request<SupplyCreateObjectV1Request, SupplyCreateObjectV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation supplyCreateObjectV1
     *
     * @param supplyCreateObjectV1Request 
     * @return RequestConfig
     */
    fun supplyCreateObjectV1RequestConfig(supplyCreateObjectV1Request: SupplyCreateObjectV1Request) : RequestConfig<SupplyCreateObjectV1Request> {
        val localVariableBody = supplyCreateObjectV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/1/object/supply",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete an existing Supply
     * 
     * @param pkiSupplyID The unique ID of the Supply
     * @return SupplyDeleteObjectV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun supplyDeleteObjectV1(pkiSupplyID: kotlin.Int) : SupplyDeleteObjectV1Response {
        val localVarResponse = supplyDeleteObjectV1WithHttpInfo(pkiSupplyID = pkiSupplyID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SupplyDeleteObjectV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete an existing Supply
     * 
     * @param pkiSupplyID The unique ID of the Supply
     * @return ApiResponse<SupplyDeleteObjectV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun supplyDeleteObjectV1WithHttpInfo(pkiSupplyID: kotlin.Int) : ApiResponse<SupplyDeleteObjectV1Response?> {
        val localVariableConfig = supplyDeleteObjectV1RequestConfig(pkiSupplyID = pkiSupplyID)

        return request<Unit, SupplyDeleteObjectV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation supplyDeleteObjectV1
     *
     * @param pkiSupplyID The unique ID of the Supply
     * @return RequestConfig
     */
    fun supplyDeleteObjectV1RequestConfig(pkiSupplyID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/1/object/supply/{pkiSupplyID}".replace("{"+"pkiSupplyID"+"}", encodeURIComponent(pkiSupplyID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Edit an existing Supply
     * 
     * @param pkiSupplyID The unique ID of the Supply
     * @param supplyEditObjectV1Request 
     * @return SupplyEditObjectV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun supplyEditObjectV1(pkiSupplyID: kotlin.Int, supplyEditObjectV1Request: SupplyEditObjectV1Request) : SupplyEditObjectV1Response {
        val localVarResponse = supplyEditObjectV1WithHttpInfo(pkiSupplyID = pkiSupplyID, supplyEditObjectV1Request = supplyEditObjectV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SupplyEditObjectV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Edit an existing Supply
     * 
     * @param pkiSupplyID The unique ID of the Supply
     * @param supplyEditObjectV1Request 
     * @return ApiResponse<SupplyEditObjectV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun supplyEditObjectV1WithHttpInfo(pkiSupplyID: kotlin.Int, supplyEditObjectV1Request: SupplyEditObjectV1Request) : ApiResponse<SupplyEditObjectV1Response?> {
        val localVariableConfig = supplyEditObjectV1RequestConfig(pkiSupplyID = pkiSupplyID, supplyEditObjectV1Request = supplyEditObjectV1Request)

        return request<SupplyEditObjectV1Request, SupplyEditObjectV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation supplyEditObjectV1
     *
     * @param pkiSupplyID The unique ID of the Supply
     * @param supplyEditObjectV1Request 
     * @return RequestConfig
     */
    fun supplyEditObjectV1RequestConfig(pkiSupplyID: kotlin.Int, supplyEditObjectV1Request: SupplyEditObjectV1Request) : RequestConfig<SupplyEditObjectV1Request> {
        val localVariableBody = supplyEditObjectV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/1/object/supply/{pkiSupplyID}".replace("{"+"pkiSupplyID"+"}", encodeURIComponent(pkiSupplyID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sSelector
     */
     enum class SSelectorSupplyGetAutocompleteV2(val value: kotlin.String) {
         @Json(name = "All") All("All");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter eFilterActive
     */
     enum class EFilterActiveSupplyGetAutocompleteV2(val value: kotlin.String) {
         @Json(name = "All") All("All"),
         @Json(name = "Active") Active("Active"),
         @Json(name = "Inactive") Inactive("Inactive");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Retrieve Supplys and IDs
     * Get the list of Supply to be used in a dropdown or autocomplete control.
     * @param sSelector The type of Supplys to return
     * @param eFilterActive Specify which results we want to display. (optional, default to Active)
     * @param sQuery Allow to filter the returned results (optional)
     * @param acceptLanguage  (optional)
     * @return SupplyGetAutocompleteV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun supplyGetAutocompleteV2(sSelector: SSelectorSupplyGetAutocompleteV2, eFilterActive: EFilterActiveSupplyGetAutocompleteV2? = EFilterActiveSupplyGetAutocompleteV2.Active, sQuery: kotlin.String? = null, acceptLanguage: HeaderAcceptLanguage? = null) : SupplyGetAutocompleteV2Response {
        val localVarResponse = supplyGetAutocompleteV2WithHttpInfo(sSelector = sSelector, eFilterActive = eFilterActive, sQuery = sQuery, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SupplyGetAutocompleteV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve Supplys and IDs
     * Get the list of Supply to be used in a dropdown or autocomplete control.
     * @param sSelector The type of Supplys to return
     * @param eFilterActive Specify which results we want to display. (optional, default to Active)
     * @param sQuery Allow to filter the returned results (optional)
     * @param acceptLanguage  (optional)
     * @return ApiResponse<SupplyGetAutocompleteV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun supplyGetAutocompleteV2WithHttpInfo(sSelector: SSelectorSupplyGetAutocompleteV2, eFilterActive: EFilterActiveSupplyGetAutocompleteV2?, sQuery: kotlin.String?, acceptLanguage: HeaderAcceptLanguage?) : ApiResponse<SupplyGetAutocompleteV2Response?> {
        val localVariableConfig = supplyGetAutocompleteV2RequestConfig(sSelector = sSelector, eFilterActive = eFilterActive, sQuery = sQuery, acceptLanguage = acceptLanguage)

        return request<Unit, SupplyGetAutocompleteV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation supplyGetAutocompleteV2
     *
     * @param sSelector The type of Supplys to return
     * @param eFilterActive Specify which results we want to display. (optional, default to Active)
     * @param sQuery Allow to filter the returned results (optional)
     * @param acceptLanguage  (optional)
     * @return RequestConfig
     */
    fun supplyGetAutocompleteV2RequestConfig(sSelector: SSelectorSupplyGetAutocompleteV2, eFilterActive: EFilterActiveSupplyGetAutocompleteV2?, sQuery: kotlin.String?, acceptLanguage: HeaderAcceptLanguage?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (eFilterActive != null) {
                    put("eFilterActive", listOf(eFilterActive.value))
                }
                if (sQuery != null) {
                    put("sQuery", listOf(sQuery.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/object/supply/getAutocomplete/{sSelector}".replace("{"+"sSelector"+"}", encodeURIComponent(sSelector.value.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter eOrderBy
     */
     enum class EOrderBySupplyGetListV1(val value: kotlin.String) {
         @Json(name = "pkiSupplyID_ASC") pkiSupplyID_ASC("pkiSupplyID_ASC"),
         @Json(name = "pkiSupplyID_DESC") pkiSupplyID_DESC("pkiSupplyID_DESC"),
         @Json(name = "fkiGlaccountID_ASC") fkiGlaccountID_ASC("fkiGlaccountID_ASC"),
         @Json(name = "fkiGlaccountID_DESC") fkiGlaccountID_DESC("fkiGlaccountID_DESC"),
         @Json(name = "fkiGlaccountcontainerID_ASC") fkiGlaccountcontainerID_ASC("fkiGlaccountcontainerID_ASC"),
         @Json(name = "fkiGlaccountcontainerID_DESC") fkiGlaccountcontainerID_DESC("fkiGlaccountcontainerID_DESC"),
         @Json(name = "fkiVariableexpenseID_ASC") fkiVariableexpenseID_ASC("fkiVariableexpenseID_ASC"),
         @Json(name = "fkiVariableexpenseID_DESC") fkiVariableexpenseID_DESC("fkiVariableexpenseID_DESC"),
         @Json(name = "sSupplyCode_ASC") sSupplyCode_ASC("sSupplyCode_ASC"),
         @Json(name = "sSupplyCode_DESC") sSupplyCode_DESC("sSupplyCode_DESC"),
         @Json(name = "sSupplyDescriptionX_ASC") sSupplyDescriptionX_ASC("sSupplyDescriptionX_ASC"),
         @Json(name = "sSupplyDescriptionX_DESC") sSupplyDescriptionX_DESC("sSupplyDescriptionX_DESC"),
         @Json(name = "dSupplyUnitprice_ASC") dSupplyUnitprice_ASC("dSupplyUnitprice_ASC"),
         @Json(name = "dSupplyUnitprice_DESC") dSupplyUnitprice_DESC("dSupplyUnitprice_DESC"),
         @Json(name = "bSupplyIsactive_ASC") bSupplyIsactive_ASC("bSupplyIsactive_ASC"),
         @Json(name = "bSupplyIsactive_DESC") bSupplyIsactive_DESC("bSupplyIsactive_DESC"),
         @Json(name = "bSupplyVariableprice_ASC") bSupplyVariableprice_ASC("bSupplyVariableprice_ASC"),
         @Json(name = "bSupplyVariableprice_DESC") bSupplyVariableprice_DESC("bSupplyVariableprice_DESC");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Retrieve Supply list
     * 
     * @param eOrderBy Specify how you want the results to be sorted (optional)
     * @param iRowMax  (optional)
     * @param iRowOffset  (optional, default to 0)
     * @param acceptLanguage  (optional)
     * @param sFilter  (optional)
     * @return SupplyGetListV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun supplyGetListV1(eOrderBy: EOrderBySupplyGetListV1? = null, iRowMax: kotlin.Int? = null, iRowOffset: kotlin.Int? = 0, acceptLanguage: HeaderAcceptLanguage? = null, sFilter: kotlin.String? = null) : SupplyGetListV1Response {
        val localVarResponse = supplyGetListV1WithHttpInfo(eOrderBy = eOrderBy, iRowMax = iRowMax, iRowOffset = iRowOffset, acceptLanguage = acceptLanguage, sFilter = sFilter)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SupplyGetListV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve Supply list
     * 
     * @param eOrderBy Specify how you want the results to be sorted (optional)
     * @param iRowMax  (optional)
     * @param iRowOffset  (optional, default to 0)
     * @param acceptLanguage  (optional)
     * @param sFilter  (optional)
     * @return ApiResponse<SupplyGetListV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun supplyGetListV1WithHttpInfo(eOrderBy: EOrderBySupplyGetListV1?, iRowMax: kotlin.Int?, iRowOffset: kotlin.Int?, acceptLanguage: HeaderAcceptLanguage?, sFilter: kotlin.String?) : ApiResponse<SupplyGetListV1Response?> {
        val localVariableConfig = supplyGetListV1RequestConfig(eOrderBy = eOrderBy, iRowMax = iRowMax, iRowOffset = iRowOffset, acceptLanguage = acceptLanguage, sFilter = sFilter)

        return request<Unit, SupplyGetListV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation supplyGetListV1
     *
     * @param eOrderBy Specify how you want the results to be sorted (optional)
     * @param iRowMax  (optional)
     * @param iRowOffset  (optional, default to 0)
     * @param acceptLanguage  (optional)
     * @param sFilter  (optional)
     * @return RequestConfig
     */
    fun supplyGetListV1RequestConfig(eOrderBy: EOrderBySupplyGetListV1?, iRowMax: kotlin.Int?, iRowOffset: kotlin.Int?, acceptLanguage: HeaderAcceptLanguage?, sFilter: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (eOrderBy != null) {
                    put("eOrderBy", listOf(eOrderBy.value))
                }
                if (iRowMax != null) {
                    put("iRowMax", listOf(iRowMax.toString()))
                }
                if (iRowOffset != null) {
                    put("iRowOffset", listOf(iRowOffset.toString()))
                }
                if (sFilter != null) {
                    put("sFilter", listOf(sFilter.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/1/object/supply/getList",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve an existing Supply
     * 
     * @param pkiSupplyID The unique ID of the Supply
     * @return SupplyGetObjectV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun supplyGetObjectV2(pkiSupplyID: kotlin.Int) : SupplyGetObjectV2Response {
        val localVarResponse = supplyGetObjectV2WithHttpInfo(pkiSupplyID = pkiSupplyID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SupplyGetObjectV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve an existing Supply
     * 
     * @param pkiSupplyID The unique ID of the Supply
     * @return ApiResponse<SupplyGetObjectV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun supplyGetObjectV2WithHttpInfo(pkiSupplyID: kotlin.Int) : ApiResponse<SupplyGetObjectV2Response?> {
        val localVariableConfig = supplyGetObjectV2RequestConfig(pkiSupplyID = pkiSupplyID)

        return request<Unit, SupplyGetObjectV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation supplyGetObjectV2
     *
     * @param pkiSupplyID The unique ID of the Supply
     * @return RequestConfig
     */
    fun supplyGetObjectV2RequestConfig(pkiSupplyID: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/object/supply/{pkiSupplyID}".replace("{"+"pkiSupplyID"+"}", encodeURIComponent(pkiSupplyID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
